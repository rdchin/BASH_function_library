#!/bin/bash
#
# Â©2024 Copyright 2024 Robert D. Chin
# Email: RDevChin@Gmail.com
#
# Usage: source common_bash_function.lib
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# +----------------------------------------+
# |        Default Variable Values         |
# +----------------------------------------+
#
VERSION="2024-01-20 20:13"
#
# WARNING: Do not define $THIS_FILE within a library script.
#
# This prevents $THIS_FILE being inadvertently re-defined and set to
# the file name of the library when the command:
# "source [ LIBRARY_FILE.lib ]" is used.
#
# +----------------------------------------+
# |            Brief Description           |
# +----------------------------------------+
#
#& Brief Description
#&
#& Library of BASH functions, common_bash_function.lib is a child dependency
#& used by assorted scripts.
#&
#& Usage: source common_bash_function.lib
#&
#&    This program is free software: you can redistribute it and/or modify
#&    it under the terms of the GNU General Public License as published by
#&    the Free Software Foundation, either version 3 of the License, or
#&    (at your option) any later version.
#&
#&
#&    This program is distributed in the hope that it will be useful,
#&    but WITHOUT ANY WARRANTY; without even the implied warranty of
#&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#&    GNU General Public License for more details.
#&
#&    You should have received a copy of the GNU General Public License
#&    along with this program.  If not, see <https://www.gnu.org/licenses/>.
#&
#&    --------------------------------------------------------------------
#&
#&    "fzf" is under the The MIT License (MIT) and Copyright (c) 2013-2023
#&    by Junegunn Choi.
#&
#&    "fzf" is an adaptable command-line fuzzy finder with an interactive
#&    interface.
#&
#&    "fzf" is used by the functions, f_select_dir_fzf and f_select_file.
#&
#&    See Junegunn Choi's Github website https://github.com/junegunn/fzf
#&    for more information.
#
# +----------------------------------------+
# |           Code Change History          |
# +----------------------------------------+
#
## Code Change History
##
## (After each edit made, please update Code History and VERSION.)
##
## 2024-01-20 *f_check_version_TEMPLATE, f_test_dash update revision date and documentation.
##
## 2024-01-19 *f_menu_main_all_menus_TEMPLATE added.
##            *f_menu_main_TEMPLATE_2 deleted in favor of f_menu_main_all_menus_TEMPLATE.
##            *f_menu_main_all_plus_TEMPLATE deleted in favor of f_menu_main_all_menus_TEMPLATE.
##
## 2024-01-16 *f_check_version_TEMPLATE, f_version_compare added
##             "Silent Mode" parameter and only ask question to update
##             if an update is needed.
##
## 2024-01-13 *f_menu_main_TEMPLATE improved comments, documentation.
##            *f_menu_main_TEMPLATE_2, f_menu_main_all_plus_TEMPLATE added.
##            *f_menu_sub_TEMPLATE deleted.
##
## 2023-12-31 *f_show_mount_points include $HOSTNAME in display.
##            *f_create_a_menu improved documentation.
##
## 2023-12-29 *f_select_dir_verify force a standard so that all dir names
##             end in a trailing "/" or no "/")
##            *f_select_file limited scope by using a directory argument
##             specifying the directory to start searching for the file.
##
## 2023-12-25 *f_select_file for "whiptail" and "text" UI uses application
##             "fzf" which is licensed under the "MIT License".
##             Improved documentation for f_select_file.
##
## 2023-12-23 *f_select_file for "whiptail" and "text" UI uses application
##             "fzf" which does a search for files. Set fzf to pattern
##             match on the starting letters of file name.
##
## 2023-12-21 *f_select_file_verify, f_select_file_output added.
##            *f_select_file simplified for "dialog" UI.
##            *f_select_dir brought improvements from Dialog to Whiptail
##             case statements.
##            *f_show_mount_points simplified.
##
## 2023-12-17 *f_select_dir, f_select_file improved look and feel with
##             better dynamic resizing of Dialog box size with a warning
##             message if X-window size is too small for Dialog box.
##            *f_select_file bug fixed to display warning if a directory is
##             selected rather than a file. Added a messoge if Dialog
##             fselect "Cancel" button is pressed.
##
## 2023-11-23 *f_show_mount_points added to display both LAN Samba shares,
##             and mount-points and locally mounted devices. such as
##             USB drives, and even RAID md devices.
##
## 2023-11-19 *f_select_dir made all UI consistent allowing one or more
##             directories to be selected by Whiptail or Text UI.
##            *f_yn_question fixed bug syntax error in case statement
##             for Dialog and Whiptail UI.
##
## 2023-10-10 *Improved comments to be more consistent.
##
## 2023-08-30 *f_web_browser added command "chromium".
##
## 2023-08-07 *f_web_browser changed order of web browser preferences.
##             Improved comments for clarity.
##
## 2023-06-09 *f_message bug fix deleted temp file when user-interface
##             is "text" and text to be displayed was in a temp file.
##
## 2023-02-06 *f_web_browser bug fix corrected command-line commands for
##             opening web browsers, Chromium and Google Chrome.
##
## 2023-01-23 *f_web_browser added.
##
## 2023-01-21 *f_text_editor fixed bug, missing parameter for f_message.
##
## 2022-10-05 *f_menu_main_TEMPLATE improved comments.
##
## 2022-09-13 *f_message added warning message in comments that any
##             text file must be a temporary file and will be deleted.
##
## 2022-09-09 *f_message bug fixed dialog/whiptail titles now display in
##             their entirety rather than being truncated if the title
##             string length is longer than the text string length.
##
## 2022-07-24 *f_abort, f_exit_script,f_update_menu_txt,
##             f_create_show_menu made minor cosmetic changes.
##             Added "clear" command.
##
## 2022-06-21 *f_select_file bug fixed if "Cancel" button pressed.
##             Also bug fixed when $4 optional filename was null.
##            *f_text_editor bug fixed when $4 optional filename was null.
##
## 2022-06-17 *f_create_a_menu, f_menu_make added and these can replace
##             f_menu_sub_TEMPLATE.
##
## 2022-06-15 *f_text_editor, f_file_manager added optional parameter to
##             force process to run in the background. Default is to run
##             the application in the foreground.
##
## 2022-06-05 *f_msg_ui_file/str_nok/ok added calculations for XSCREEN and
##             YSCREEN because some scripts may call those functions directly
##             without calling f_message which sets XSCREEN and YSCREEN.
##
## 2022-06-03 *f_update_menu_gui, f_update_menu_txt corrected comments
##             in generated file.
##            *f_version_compare, f_create_show_menu added variables.
##
## 2022-05-20 *f_version_compare, f_check_version_TEMPLATE improved user
##             messages.
##            *f_message added debug hint comment.
##            *f_msg_ui_str_box_size, f_msg_ui_file_box_size corrected
##             comments.
##
## 2022-05-17 *f_ask_question corrected documentation of ERROR=1 or 255.
##             Bug fixed with $3 parameter needing quotes as it could be a
##             file name or a string of words.
##            *f_select_file improved user messages. Bug fixed where if-then
##             statements test $4 parameter as integer rather than a string.
##             Changed to display user message "File Entered" only if selecting
##             multiple files.
##            *f_select_dir changed to display user message "Directory Entered"
##             only if selecting multiple directories.
##
## 2022-04-29 *Improved comments for passing strings as parameters
##             for many functions.
##            *f_select_dir corrected user message.
##
## 2022-04-27 *f_select_file bug fixed when $4=1 to select a single file,
##             output ANS was not set correctly.
##            *f_text_editor bug fixed by deleting the ampersand after the
##             command so scripts that are dependent on the edited file don't
##             keep running before edited file is saved.
##
## 2022-04-24 *f_username changed prompt include more context.
##            *f_password changed prompt and delete temporary files
##             immediately after usage.
##
## 2022-04-18 *f_select_file added a Go/NoGo confirmation question and
##             improved user messages.
##            *f_select_dir improved user messages.
##
## 2022-04-14 *f_file_manager added instructions on how to exit out of the
##             CLI applications and changed run command to exit out directly
##             to men.sh rather than to the invoked bash shell and having to
##             exit out from that environment also.
##             Change from: eval $FILE_MGR $2 &
##             Change   to: $FILE_MGR $2
##             Also made the application Ranger the preferred CLI app and
##             improved comments.
##            *f_text_editor added Nano as the preferred CLI editor app and
##             improved comments.
##
## 2022-04-08 *f_file_manager, f_text_editor bug fix to detect CLI or
##             XWINDOW environment and use appropriate app.
##            *Section "Customize Menu choice options below" deleted
##             since it would never work because a menu display would be
##             dependent on f_display_common which is in each script and
##             customized for that script based on f_display_common_TEMPLATE.
##             Therefore any f_display_common function in this script would
##             interfere with the customized version in each parent script.
##
## 2022-04-06 *f_select_file, f_select_dir bug fixed with $4 optional
##             parameter change if statement from number to string compare.
##
## 2022-04-01 *Library-wide improved comments on function specifications.
##            *f_default_ans improved comments.
##
## 2022-03-30 *f_select_dir, f_select_file added optional parameter to
##             select only a single directory_file.
##
## 2022-03-29 *f_ask_question enhanced to accept a text file as text for a
##             question. Text within the file is converted to a single-line
##             string with "\n" marking line endings.
##
## 2022-03-26 *f_file_manager, f_text_editor changed to run processes in
##             the background.
##
## 2022-03-09 *f_file_manager improved user messages.
##
## 2022-03-08 *f_ask_question bug fixed in text UI using wrong variable name.
##            *f_msg_ui_str_ok increase box height calculation.
##
## 2022-02-27 *f_ask_question bug fixed calculation of box size.
##            *f_select_file, f_select_dir improved user messages.
##
## 2022-02-26 *f_select_dir, f_select_file changed default directory to
##             be the last selected directory when using Dialog in a loop.
##
## 2022-02-25 *f_check_version_TEMPLATE added code to assure FILE_LIST is
##             not appended to but is newly created.
##
## 2022-02-24 *f_msg_txt/ui_file/str_nok added comments.
##            *f_select_file, f_select_dir changed minimum X-Window size
##             settings, added more error checking. File description string
##             is now limited to 28 characters to work on 80x24 displays.
##             It is used in the "--ok-label" "--back-title" options.
##
## 2022-02-23 *f_ask_question added.
##
## 2022-01-30 *f_select_directory, f_select_file require a minimum X-window
##             size for the Dialog command "f_select".
##
## 2022-01-22 *f_file_manager, f_text_editor, f_select_directory,
##             f_select_file added.
##
## 2022-01-21 *f_mount added option to specify the default user name.
##
## 2021-06-18 *f_update_menu_txt fixed bug where given two menu option names
##             of which one included the name of the other, the shorter
##             name would always be selected when typing the name.
##             i.e. Menu options: "apple", "apple pie".
##             When typing "apple pie" then "apple" would be selected.
##
## 2021-03-31 *f_version_compare changed user-message question format to be
##             more consistent with previous informative user-message.
##            *f_display_common_TEMPLATE improved comments.
##            *Generally improved comments.
##
## 2021-03-29 *f_version_compare changed user-message to be more consistent
##             with Linux file manager user-message when copying files.
##
## 2021-03-28 *f_arguments changed to detect if an argument is a file or
##             directory name and if not, display appropriate error message.
##            *f_source bug fixed initialized ERROR.
##
## 2021-03-25 *f_check_version typo fixed.
##
## 2021-03-24 *f_arguments changed -u option variable used.
##             Change from: $TARGET_DIR
##             Change   to: $LOCAL_REPO_DIR
##            *f_check_version_TEMPLATE, f_version_compare updated to add
##             a second optional argument.
##            *f_version_compare fixed bug initialized ANS, improved user
##             messages and comments.
##
## 2021-03-12 *f_check_version_TEMPLATE corrected summary comment.
##            *f_version_compare rewrote summary comment.
##
## 2021-03-09 *Standardized some comments.
##
## 2021-03-08 *f_source_TEMPLATE renamed to f_source, since there is no
##             customization.
##            *f_mount improved comments.
##
## 2021-03-07 *f_update_menu_gui/txt bug fix for grep --text when searching
##             for the Copyright line where the Copyright symbol may make
##             certain versions of grep treat the script as a binary file.
##            *f_check_file deleted as obsoleted by f_source_TEMPLATE.
##            *f_download_library, f_download_local deleted as obsolete.
##            *f_download_file added to download files.
##            *f_download_from_local_repository added.
##            *f_download_from_web_site added.
##            *Enhanced comments added "Summary" and "Dependencies".
##
## 2021-02-23 *f_version_compare prevented user message from displaying when
##             a comparison is impossible (repository is unavailable).
##
## 2021-02-16 *f_menu_main_TEMPLATE, f_menu_sub_TEMPLATE added Summary.
##
## 2021-02-14 *f_message fixed bug where temporary file was not deleted.
##            *f_msg_ui_str_box_size added warning comment to aid debugging.
##
## 2021-02-13 *Updated to latest standards.
##            *f_update_menu_txt changed menu item text.
##
## 2021-02-09 *Updated to latest standards.
##
## 2021-02-08 *Updated to latest standards. f_check_version_TEMPLATE,
##             f_display_common_TEMPLATE, f_menu_main_TEMPLATE,
##             f_menu_sub_TEMPLATE.
##
## 2021-01-29 *f_source_TEMPLATE added.
##
## 2021-01-27 *f_message, f_msg_ui_str_ok, f_msg_ui_file_ok added feature
##             to substitute labels for the "OK" and "Exit" buttons.
##
## 2021-01-17 *f_version_compare improve messages to user.
##
## 2021-01-14 *"Brief Description" added General Public License 3 notice.
##            *Added General Public License 3 notice at head of script.
##
## 2020-12-18 *"Help and Usage" message improved.
##            *f_arguments updated comments.
##
## 2020-12-11 *f_version_compare allowed logging of file copy errors.
##            *f_download_from_local_repository allowed logging of
##             file copy errors.
##
## 2020-11-25 *f_version_compare improved display messages.
##
## 2020-10-27 *Updated to latest standards.
##
## 2020-10-25 *f_username improved messages.
##
## 2020-10-23 *f_check_version_TEMPLATE improved comments.
##
## 2020-10-22 *f_arguments, "Help and Usage" added option --update -u.
##
## 2020-09-30 *Sample Main Program code was deleted and included in the
##             script example.sh.
##
## 2020-09-22 *f_version_compare added a message on successful update.
##
## 2020-09-19 *f_menu_main_TEMPLATE added comments.
##            *f_menu_sub_TEMPLATED added.
##            *f_check_version_TEMPLATE added comments.
##
## 2020-09-14 *f_version_compare added an error message if repository directory is missing.
##
## 2020-09-13 *f_check_version_TEMPLATE, f_version_compare added to compare file versions
##             of file in LAN Repository and local file.
##            *f_version deleted, incorporated into f_version_compare.
##            *f_mount added.
##
## 2020-09-11 *f_username fixed bug where dialog/whiptail did not work.
##
## 2020-09-09 *Main (example) display Brief Discription for only 1 second.
##
## 2020-09-07 *f_version added to get version of script from a local repository.
##            *f_download_local_TEMPLATE, f_check_file_TEMPLATE added.
##
## 2020-08-10 *f_yn_defaults bug fixed for text UI when displaying question.
##
## 2020-08-07 *f_msg_ui_file_nok bug fix for Dialog to exclude "OK" button.
##            *f_display_common, f_about, f_code_history, f_help_message
##             updated to add option to display without an "OK" button in Dialog.
##             However, Whiptail only displays with an "OK" button.
##
## 2020-08-06 *f_display_common_TEMPLATE, f_download_library_TEMPLATE,
##            *f_menu_main_TEMPLATE, f_test_connect_TEMPLATE changed comments
##             to standize format of template functions.
##
## 2020-07-31 *Main bug fix pattern matching code to download Common BASH Library.
##
## 2020-07-16 *f_update_menu_txt bug fixed due to ommitting comment mark.
##            *f_test connection added a pause to vary the seconds the message is displayed.
##            *f_yn_question, f_yn_defaults, f_message, f_msg_ui_file_box_size f_msg_ui_str_box_size,
##             simplified code inputs needed.
##            *f_create_show_menu changed from "." to "source".
##            *f_update_menu_txt fixed bug where lack of comment marker "#" caused bug.
##
## 2020-07-01 *f_about, f_display_common_TEMPLATE fixed comments.
##
## 2020-06-27 *f_display_common, f_about, f_code_history, f_help_message
##             rewritten to simplify code.
##
## 2020-06-25 *f_arguments corrected comments to show option for 2 arguments.
##            *f_update_menu_gui/txt corrected comments and specified directory of library.
##
## 2020-06-23 *Do not declare variables THIS_FILE and TEMP_FILE so when this
##             library is invoked, these variables are not overwritten.
##            *f_test_connect_template added, f_test_connect deleted.
##            *f_about_template added, f_about deleted.
##            *f_code_history_template, f_code_history deleted.
##            *f_help_message_template added, f_help_message deleted.
##            *f_download_library_template added, f_download deleted.
##            *f_menu_main_template added, f_menu deleted.
##
## 2020-06-22 *f_arguments enhanced to allow 1st argument as a directory
##             and 2nd argument as UI.
##            *f_test_dash clean up call to f_abort had 2 OPTIONS instead of 1.
##
## 2020-06-04 *f_update_menu/txt/gui cosmetic changes.
##            *f_message, f_msg_ui_file_nok dialog textbox cannot use sleep n delay.
##            *f_msg_color bug fixed, cannot use variables in case pattern matching.
##
## 2020-05-23 *f_update_menu_txt/gui fixed bugs/typos.
##            *"Help & Usage" added spaces.
##            *"Brief Description" changed delimiter.
##            *f_about, f_code_history, f_help_message added DELIM.
##
## 2020-05-22 *f_message, f_msg_txt_file_nok, f_msg_txt_str_nok,
##             f_msg_ui_file_nok, f_msg_ui_str_nok added variable sleep seconds.
##
## 2020-05-20 *f_update_menu_txt/gui cleaned up comments in generated code.
##
## 2020-05-18 *f_update_menu/gui/txt cosmetic fixed comments.
##            *f_main_menu, f_update_menu_gui, f_menu_arrays fixed bug in
##             calculating menu width for displaying on screen.
##
## 2020-05-15 *f_test_connection changed message from "Internet" to "Network".
##            *f_main_menu, f_create_show_menu, f_update_menu_txt/gui added
##             unique TEMP_FILE name to prevent over-writing.
##            *f_update_menu_txt/gui changed f_menu_txt/gui to be unique
##             with each file $GENERATED_FILE so you can have several sub-menus
##             open simultaneously each with a unique f_menu_txt/gui function names.
##
## 2020-05-14 *f_yn_question fixed bug where temp file was undefined.
##            *msg_ui_str_nok, f_msg_txt_str_nok changed wait time
##             from 5 to 3 seconds.
##            *f_exit_script to latest standard; clean-up temp files on exit.
##            *f_message, f_msg_ui_file_box_size, f_msg_ui_str_box_size,
##             f_ui_file_ok/nok, f_ui_str_ok/nok f_yn_question/defaults
##             specified parameter passing.
##            *f_menu_arrays, f_update_menu_txt/gui bug fixed to not unset
##             TEMP_FILE variable since it is used globally.
##
## 2020-05-06 *f_msg_ui_file_box_size, f_msg_ui_file_ok bug fixed in display.
##
## 2020-05-04 *f_update_menu_gui adjusted menu display parameters for Whiptail.
##
## 2020-05-01 *f_msg_color fixed bug if string had no "\Z" command,
##             it would not be displayed.
##
## 2020-04-28 *f_message, f_msg* improve Dialog "\Z" command handling.
##
## 2020-04-22 *f_message split into several functions for clarity and
##             simplicity f_msg_(txt/ui)_(file/string)_(ok/nok).
##            *f_yn_question split off f_yn_defaults.
##
## 2020-04-19 *Found bug in VERSION setting in f_about, f_code_history,
##             f_help_message. Need to set $VERSION using correct $THIS_FILE.
##
## 2020-04-18 *Fixed bug affecting menu items "About", "Code History",
##             and "Help" where f_update menu_gui/txt did not substitute
##             the "^" <carot> for <space> in FUNC="f_<function>^$GUI".
##             So $1 was never set to $GUI when calling f_about,
##             f_code_history, and f_help_message.
##
## 2020-04-15 *Standardized code to latest implementations.
##            *f_message total rewrite to handle text file, strings with
##             or without embedded "/n" or "/Zn" commands.
##
## 2020-04-07 *Cosmetic formatting changes in if-then, case, statements
##             and comment lines.
##
## 2020-04-06 *f_arguments standardized.
##
## 2020-04-06 *Initial Release.
#
# +------------------------------------+
# |     Function f_display_common_TEMPLATE      |
# +------------------------------------+
#
#     Rev: 2021-03-31
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - Delimiter of text to be displayed.
#          $3 - "NOK", "OK", or null [OPTIONAL] to control display of "OK" button.
#          $4 - Pause $4 seconds [OPTIONAL]. If "NOK" then pause to allow text to be read.
#          THIS_DIR, THIS_FILE, VERSION.
#    Uses: X.
# Outputs: None.
#
# Summary: Display lines of text beginning with a given comment delimiter.
#
# Dependencies: f_message.
#
# PLEASE NOTE: RENAME THIS FUNCTION WITHOUT SUFFIX "_TEMPLATE" AND COPY
#              THIS FUNCTION INTO ANY SCRIPT WHICH DEPENDS ON THE
#              LIBRARY FILE "common_bash_function.lib".
#
f_display_common_TEMPLATE () {
      #
      # Set $THIS_FILE to the file name containing the text to be displayed.
      #
      # WARNING: Do not define $THIS_FILE within a library script.
      #
      # This prevents $THIS_FILE being inadvertently re-defined and set to
      # the file name of the library when the command:
      # "source [ LIBRARY_FILE.lib ]" is used.
      #
      # For that reason, all library files now have the line
      # THIS_FILE="[LIBRARY_FILE.lib]" commented out or deleted.
      #
      #
      #==================================================================
      # EDIT THE LINE BELOW TO DEFINE $THIS_FILE AS THE ACTUAL FILE NAME
      # CONTAINING THE BRIEF DESCRIPTION, CODE HISTORY, AND HELP MESSAGE.
      #==================================================================
      #
      #
      THIS_FILE="[ THIS FILE GOES HERE ]"  # <<<--- INSERT ACTUAL FILE NAME HERE.
      #
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
      #
      # Set $VERSION according as it is set in the beginning of $THIS_FILE.
      X=$(grep --max-count=1 "VERSION" $THIS_FILE)
      # X="VERSION=YYYY-MM-DD HH:MM"
      # Use command "eval" to set $VERSION.
      eval $X
      #
      echo "Script: $THIS_FILE. Version: $VERSION" > $TEMP_FILE
      echo >>$TEMP_FILE
      #
      # Display text (all lines beginning ("^") with $2 but do not print $2).
      # sed substitutes null for $2 at the beginning of each line
      # so it is not printed.
      sed -n "s/$2//"p $THIS_DIR/$THIS_FILE >> $TEMP_FILE
      #
      case $3 in
           "NOK" | "nok")
              f_message $1 "NOK" "Message" $TEMP_FILE $4
           ;;
           *)
              f_message $1 "OK" "(use arrow keys to scroll up/down/side-ways)" $TEMP_FILE
           ;;
      esac
      #
} # End of function f_display_common_TEMPLATE.
#
# +----------------------------------------+
# |        Function f_check_version_TEMPLATE        |
# +----------------------------------------+
#
#     Rev: 2024-01-16
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - [OPTIONAL] File name to compare.
#          $3 - [OPTIONAL] 1=Silent mode.
#          FILE_TO_COMPARE.
#    Uses: SERVER_DIR, MP_DIR, LOCAL_REPO_DIR, $FILE_TO_COMPARE, FILE_LIST,
#          VERSION, TEMP_FILE, ERROR.
# Outputs: ERROR.
#
# Summary: Check the version of a single, local file or script,
#          FILE_TO_COMPARE with the version of repository file.
#          If the repository file has latest version, then copy all
#          dependent files and libraries from the repository to local PC.
#
# TO DO enhancement: If local (LAN) repository is unavailable, then
#          connect to repository on the web if available.
#
# Dependencies: f_version_compare.
#
# PLEASE NOTE: RENAME THIS FUNCTION WITHOUT SUFFIX "_TEMPLATE" AND COPY
#              THIS FUNCTION INTO ANY SCRIPT WHICH DEPENDS ON THE
#              LIBRARY FILE "common_bash_function.lib".
#
f_check_version_TEMPLATE () {
      #
      #
      #=================================================================
      # EDIT THE LINES BELOW TO DEFINE THE LAN FILE SERVER DIRECTORY,
      # LOCAL MOUNTPOINT DIRECTORY, LOCAL REPOSITORY DIRECTORY AND
      # FILE TO COMPARE BETWEEN THE LOCAL PC AND (LAN) LOCAL REPOSITORY.
      #=================================================================
      #
      #
      # LAN File Server shared directory.
      # SERVER_DIR="[FILE_SERVER_DIRECTORY_NAME_GOES_HERE]"
        SERVER_DIR="//file_server/public"
      #
      # Local PC mount-point directory.
      # MP_DIR="[LOCAL_MOUNT-POINT_DIRECTORY_NAME_GOES_HERE]"
        MP_DIR="/mnt/file_server/public"
      #
      # Local PC mount-point with LAN File Server Local Repository full directory path.
      # Example:
      #                   File server shared directory is "//file_server/public".
      # Repository directory under the shared directory is "scripts/BASH/Repository".
      #                 Local PC Mount-point directory is "/mnt/file_server/public".
      #
      # Local PC mount-point with LAN File Server Local Repository full directory path.
      # LOCAL_REPO_DIR="$MP_DIR/[DIRECTORY_PATH_TO_LOCAL_REPOSITORY]"
        LOCAL_REPO_DIR="$MP_DIR/scripts/BASH/Repository"
      #
      # Local PC file to be compared.
      if [ $# -eq 2 ] ; then
         # There are 2 arguments that have been passed to this function.
         # $2 contains the file name to compare.
         FILE_TO_COMPARE=$2
      else
         # $2 is null, so specify file name.
         if [ -z "$FILE_TO_COMPARE" ] ; then
            # FILE_TO_COMPARE is undefined so specify file name.
            FILE_TO_COMPARE=$(basename $0)
         fi
      fi
      #
      # Version of Local PC file to be compared.
      VERSION=$(grep --max-count=1 "VERSION" $FILE_TO_COMPARE)
      #
      # Initialize variables.
      FILE_LIST=$THIS_DIR/$THIS_FILE"_file_temp.txt"
      ERROR=0
      #
      # Delete any existing file.
      # This assures that FILE_LIST is not appended to but is newly created
      # in the code below. Added because typo may occur when using redirection
      # where typo ">>" is used instead of ">" at FILE NAME1.
      # i.e. typo at echo "[ FILE NAME1 GOES HERE ]"  >> $FILE_LIST
      if [ -e $FILE_LIST ] ; then
         rm $FILE_LIST
      fi
      #
      #
      #=================================================================
      # EDIT THE LINES BELOW TO SPECIFY THE FILE NAMES TO UPDATE.
      # FILE NAMES INCLUDE ALL DEPENDENT SCRIPTS AND LIBRARIES.
      #=================================================================
      #
      #
      # Create list of files to update and write to temporary file, FILE_LIST.
      #
      #echo "[ FILE NAME1 GOES HERE ]"  > $FILE_LIST  # <<<--- INSERT ACTUAL FILE NAME HERE.
      #echo "[ FILE NAME2 GOES HERE ]" >> $FILE_LIST  # <<<--- INSERT ACTUAL FILE NAME HERE.
      #echo "[ FILE NAME3 GOES HERE ]" >> $FILE_LIST  # <<<--- INSERT ACTUAL FILE NAME HERE.
      #echo "[ FILE NAME4 GOES HERE ]" >> $FILE_LIST  # <<<--- INSERT ACTUAL FILE NAME HERE.
      #
      f_version_compare $1 "$SERVER_DIR" "$MP_DIR" "$LOCAL_REPO_DIR" "$FILE_TO_COMPARE" "$VERSION" "$FILE_LIST" $3
      #
      if [ -r  $FILE_LIST ] ; then
         rm  $FILE_LIST
      fi
      #
      unset FILE_LIST
      #
}  # End of function f_check_version_TEMPLATE.
#
# +----------------------------------------+
# |       Function f_version_compare       |
# +----------------------------------------+
#
#     Rev: 2024-01-16
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - Samba File server Directory
#          $3 - Local Mount Point (Directory)
#          $4 - File server Target Directory.
#          $5 - File server Target File name.
#          $6 - Version of Local file. String.
#          $7 - Temporary file name with list of files to be upgraded.
#          $8 - 1=Silent mode without displaying questions or status.
#               Display error messages only.
#    Uses: LINE, VER, VER_MSG, VERSION_RELEASE, ERROR2.
# Outputs: ERROR, ANS.
#
# Summary: Compare the version of a single local script against the
#          version $6 of file $5 in the Local (LAN, non-web) repository
#          directory $4 .
#
# Dependencies: f_message, f_mount, f_yn_question.
#
f_version_compare () {
      #
      # Get the version number of the Local software script file.
      #
      # Each file script contains the string "VERSION=[ YYYY-MM-DD HH:MM ]"
      # i.e. VERSION="2020-12-31 23:59"
      #
      # Change string $VER_LOCAL from: VERSION="2020-12-31 23:59"
      #                            to: 2020-12-31 23:59           (without quotes within string).
      VER_LOCAL=$(echo $6 | sed 's/VERSION=//' | sed 's/\"//g')
      #
      # Initialize $ANS to "No" answer for f_yn_question "Copy from Repository?"
      ANS=1
      #
      # Does the Local Mount Point directory exist?
      if [ ! -e "$3" ] ; then
         # No, directory is missing.
         f_message $1 "NOK" "Error missing directory" "Missing local mountpoint directory\n$3." 2
      else
         # Yes, directory is OK so mount the file server directory.
         f_mount $1 $2 $3
         #
         # Were there any errors when mounting?
         if [ $ERROR -eq 0 ] ; then
            # No, File Server directory is mounted.
            #
            if [ -e $4/$5 ] ; then
               # Get the version number of the target software script.
               #
               # Each file script contains the string "VERSION=[ YYYY-MM-DD HH:MM ]"
               # i.e. VERSION="2020-12-31 23:59"
               #
               VER_REPO=$(grep --max-count=1 "VERSION" "$4"/"$5")
               #
               # Change string $VERSION_REPO from: VERSION="2020-12-31 23:59"
               #                               to: 2020-12-31 23:59           (without quotes within string).
               VER_REPO=$(echo $VER_REPO | sed 's/VERSION=//' | sed 's/\"//g')
               #
               VER_MSG=$7"_MSG.txt"
               #
               # f_message $1 "OK" "Diagnostic Line common_bash_function.lib 737" "Silent Mode=$8 VER_LOCAL=$VER_LOCAL VER_REPO=$VER_REPO"  # Diagnostic line.
               #
               # Is "Silent Mode" deactivated and update needed?
               if [ -z "$8" ] && [ "$VER_LOCAL" != "$VER_REPO" ]; then
                  # Yes, display message.
                  echo "Replace Files on this PC?" > $VER_MSG
                  echo >> $VER_MSG
                  echo "***Original Software Version on this PC***" >> $VER_MSG
                  echo "$VER_LOCAL" >> $VER_MSG
                  echo >> $VER_MSG
                  echo "***Replace with***" >> $VER_MSG
                  echo "$VER_REPO" >> $VER_MSG
                  echo >> $VER_MSG
                  echo "Replace files below:" >> $VER_MSG
                  cat $7 >> $VER_MSG
                  echo >> $VER_MSG
                  echo "with files from Local Repository at" >> $VER_MSG
                  echo "$4" >> $VER_MSG
                  f_message $1 "OK" "List of Files to be Copied" $VER_MSG
               fi
               #
               # Delete temporary file.
               if [ -e $VER_MSG ] ; then
                  rm $VER_MSG
               fi
               #
            else
               f_message $1 "OK" "Error Missing Local Repository File to compare" "Failed to access file to compare \"$5\" in Local Repository. Cannot compare script versions."
               ERROR=1
            fi
            #
         else
            f_message $1 "OK" "Error Mounting Local Repository Directory" "Failed to mount Local Repository Directory \"$4\". Cannot compare script versions."
         fi
         #
         # Is an update needed?
         if [ $ERROR -eq 0 ] && [ "$VER_LOCAL" != "$VER_REPO" ]; then
             Is "Silent Mode" activated?
            if [ -z "$8" ] ; then
               # "Silent Mode" inactive, display question.
               f_yn_question $1 "N" "Copy from Repository?" "Original software version on this PC:\n   $VER_LOCAL\n\nReplace with Repository software version:\n   $VER_REPO\n\nand OVERWRITE original files on this PC?"
            else
               # "Silent Mode" active, force automatic copy from Repository.
               ANS=0
            fi
            #
            if [ $ANS -eq 0 ] ; then
               # Yes, copy from repository.
               # Update files required for this script.
               #
               # Initialize variable.
               ERROR2=0
               TEMP_FILE="common_bash_function.lib_temp.txt"
               while read LINE
                     do
                        echo > $TEMP_FILE
                        echo "Copying File from Local Repository\n$4/$LINE" >> $TEMP_FILE
                        cp -p "$4"/$LINE . 2>>$TEMP_FILE # Write any error messages to file $TEMP_FILE.
                        ERROR=$?
                        #
                        # Make file executable (useable).
                        chmod +x $LINE 2>>$TEMP_FILE # Write any error messages to file $TEMP_FILE.
                        let ERROR=$ERROR+$?
                        #
                        if [ $ERROR -ne 0 ] ; then
                           f_message $1 "OK" "Error Copying File from Local Repository" "$TEMP_FILE"
                           ERROR2=1
                        else
                           f_message $1 "NOK" "Copying File from Local Repository" $TEMP_FILE 2
                        fi
                        #
                       done < $7
               unset LINE
               #
               if [ $ERROR2 -ne 0 ] ; then
                  f_message $1 "OK" "Error occurred" $TEMP_FILE
                  ERROR=1
               else
                  ERROR=0
                  # Is "Silent Mode" activated?
                  if [ -z "$8" ] ; then
                     # "Silent Mode" inactive, display question.
                     f_message $1 "NOK" "Successful Update" "Latest version was successfully copied for use.\nScript must be re-started to use the latest version."
                  fi
               fi
            fi
         else
            # Is "Silent Mode" activated?
            if [ -z "$8" ] ; then
               # "Silent Mode" inactive, display question.
               f_message $1 "NOK" "Software Not Updated" "Software is at the latest version. No update needed."
            fi
         fi
      fi
      #
      unset LINE VER VER_MSG VERSION_RELEASE ERROR2
      #
}  # End of function f_version_compare.
#
# +----------------------------------------+
# |         Function f_script_path         |
# +----------------------------------------+
#
#     Rev: 2020-03-07
#  Inputs: $BASH_SOURCE (System variable).
#    Uses: None.
# Outputs: SCRIPT_PATH, THIS_DIR.
#
# Summary: Detect current directory and set path variables.
#
# Dependencies: None.
#
f_script_path () {
      #
      # BASH_SOURCE[0] gives the filename of the script.
      # dirname "{$BASH_SOURCE[0]}" gives the directory of the script
      # Execute commands: cd <script directory> and then pwd
      # to get the directory of the script.
      # NOTE: This code does not work with symlinks in directory path.
      #
      # !!!Non-BASH environments will give error message about line below!!!
      SCRIPT_PATH=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
      THIS_DIR=$SCRIPT_PATH  # Set $THIS_DIR to location of this script.
      #
}  # End of function f_script_path.
#
# +----------------------------------------+
# |         Function f_arguments           |
# +----------------------------------------+
#
#     Rev: 2021-03-28
#  Inputs: $1 - Argument
#             [ --help ] [ -? ]
#             [ --about ]
#             [ --version ] [ --ver ] [ -v ] [--about ]
#             [ --update ] [ -u ]
#             [ --history ] [ --hist ]
#             [] [ text ] [ dialog ] [ whiptail ]
#          $2=Argument
#             [] [ text ] [ dialog ] [ whiptail ]
#    Uses: None.
# Outputs: GUI, ERROR.
#
# Summary: Validate and process provided arguments.
#
# Dependencies: f_about, f_check_version, f_code_history, f_help_message.
#
f_arguments () {
      #
      # If there is more than two arguments, display help USAGE message, because only one argument is allowed.
      if [ $# -ge 3 ] ; then
         f_help_message text
         #
         clear # Blank the screen.
         #
         exit 0  # This cleanly closes the process generated by #!bin/bash.
                 # Otherwise every time this script is run, another instance of
                 # process /bin/bash is created using up resources.
      fi
      #
      case $2 in
           "text" | "dialog" | "whiptail")
           GUI=$2
           ;;
      esac
      #
      case $1 in
           --help | "-?")
              # If the one argument is "--help" display help USAGE message.
              if [ -z $GUI ] ; then
                 f_help_message text
              else
                 f_help_message $GUI
              fi
              #
              clear # Blank the screen.
              #
              exit 0  # This cleanly closes the process generated by #!bin/bash.
                      # Otherwise every time this script is run, another instance of
                      # process /bin/bash is created using up resources.
           ;;
           --about | --version | --ver | -v)
              if [ -z $GUI ] ; then
                 f_about text "OK"
              else
                 f_about $GUI "OK"
              fi
              #
              clear # Blank the screen.
              #
              exit 0  # This cleanly closes the process generated by #!bin/bash.
                      # Otherwise every time this script is run, another instance of
                      # process /bin/bash is created using up resources.
           ;;
           --history | --hist)
              if [ -z $GUI ] ; then
                 f_code_history text
              else
                 f_code_history $GUI
              fi
              #
              clear # Blank the screen.
              #
              exit 0  # This cleanly closes the process generated by #!bin/bash.
                      # Otherwise every time this script is run, another instance of
                      # process /bin/bash is created using up resources.
           ;;
           --update | -u)
              if [ -z $GUI ] ; then
                 f_check_version text
              else
                 f_check_version $GUI
              fi
              #
              clear # Blank the screen.
              #
              exit 0  # This cleanly closes the process generated by #!bin/bash.
                      # Otherwise every time this script is run, another instance of
                      # process /bin/bash is created using up resources.

           ;;
           -*)
              # If the one argument is "-<unrecognized>" display help USAGE message.
              if [ -z $GUI ] ; then
                 f_help_message text
              else
                 f_help_message $GUI
              fi
              #
              clear # Blank the screen.
              #
              exit 0  # This cleanly closes the process generated by #!bin/bash.
                      # Otherwise every time this script is run, another instance of
                      # process /bin/bash is created using up resources.
           ;;
           "text" | "dialog" | "whiptail")
              GUI=$1
           ;;
           "")
           # No action taken as null is a legitimate and valid argument.
           ;;
           *)
              # Check for 1st argument as a valid TARGET DIRECTORY.
              #
              # Initialize ERROR.
              ERROR=0
              #
              if [ -d $1 ] ; then
                 # $1 is a valid directory so set TARGET_DIR.
                 TARGET_DIR=$1
                 ERROR=0
              else
                 # $1 is an invalid directory.
                 ERROR=1
                 #
                 # Check for 1st argument as a valid TARGET FILE NAME.
                 if [ -e $1 ] ; then
                    # $1 is a valid full path file name so set TARGET_FILE.
                    TARGET_FILE=$1
                    ERROR=0
                 else
                    # $1 is an invalid file name.
                    ERROR=1
                 fi
              fi
              #
              if [ $ERROR -eq 1 ] ; then
                 # Error $1 is not a directory nor a file name.
                 # Display help USAGE message.
                 f_message "text" "OK" "Error Invalid File or Directory Name" "\Zb\Z1This File or Directory does not exist:\Zn\n $1"
                 f_help_message "text"
                 exit 0  # This cleanly closes the process generated by #!bin/bash.
                         # Otherwise every time this script is run, another instance of
                         # process /bin/bash is created using up resources.
              fi
           ;;
      esac
      #
}  # End of function f_arguments.
#
# +----------------------------------------+
# |          Function f_detect_ui          |
# +----------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: None.
#    Uses: ERROR.
# Outputs: GUI (dialog, whiptail, text).
#
# Summary: Detect the UI in order of preference Dialog, Whiptail, or CLI.
#
# Dependencies: Dialog/Whiptail.
#
f_detect_ui () {
      #
      # Test if Dialog UI is installed.
      command -v dialog >/dev/null
      # "&>/dev/null" does not work in Debian distro.
      # 1=standard messages, 2=error messages, &=both.
      ERROR=$?
      #
      # Is Dialog is installed?
      if [ $ERROR -eq 0 ] ; then
         # Yes, Dialog installed.
         GUI="dialog"
      else
         # Is Whiptail UI installed?
         command -v whiptail >/dev/null
         # "&>/dev/null" does not work in Debian distro.
         # 1=standard messages, 2=error messages, &=both.
         ERROR=$?
         if [ $ERROR -eq 0 ] ; then
            # Yes, Whiptail installed.
            GUI="whiptail"
         else
            # No CLI dialog box applications are installed
            GUI="text"
         fi
      fi
      #
}  # End of function f_detect_ui.
#
# +----------------------------------------+
# |      Function f_test_environment       |
# +----------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - X-window Application name.
#                  (String must either begin and end with double-quotes
#                  or must not include spaces but must have underscores substituting for spaces).
#          $BASH_VERSION (System variable).
#    Uses: None.
# Outputs: None.
#
# Summary: Test for shell and then for an X-Window environment.
#
# Dependencies: f_abort, f_message, f_test_dash.
#
f_test_environment () {
      #
      # What shell is used? DASH or BASH?
      f_test_dash $1
      #
      # Test for X-Windows environment. Cannot run in CLI for LibreOffice.
      #if [ x$DISPLAY = x ] ; then
      #   f_message $1 "OK" "Cannot run $2" "Cannot run $2 without an X-Windows environment.\ni.e. application $2 must run in a terminal emulator in an X-Window."
      #   f_abort $1
      #fi
      #
}  # End of function f_test_environment.
#
# +----------------------------------------+
# |          Function f_test_dash          |
# +----------------------------------------+
#
#     Rev: 2024-01-20
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $BASH_VERSION (System variable), GUI.
#    Uses: None.
# Outputs: exit 1.
#
# Summary: Test the environment. Are you in the BASH environment?
#          Some scripts will have errors in the DASH environment that is the
#          default command-line interface shell in Ubuntu.
#
# Dependencies: f_message, f_abort.
#
f_test_dash () {
      #
      # $BASH_VERSION is null if you are not in the BASH environment.
      # Typing "sh" at the CLI may invoke a different shell other than BASH.
      # if [ -z "$BASH_VERSION" ]; then
      # if [ "$BASH_VERSION" = '' ]; then
      #
      if [ -z "$BASH_VERSION" ]; then
         # DASH Environment detected, display error message
         # to invoke the BASH environment.
         f_detect_ui # Automatically detect UI environment.
         #
         TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
         #
         clear  # Blank the screen.
         #
         f_message $1 "OK" ">>> Warning: Must use BASH <<<" "\n                   You are using the DASH environment.\n\n        *** This script cannot be run in the DASH environment. ***\n\n    Ubuntu and Linux Mint default to DASH but also have BASH available."
         f_message $1 "OK" "HOW-TO" "\n  You can invoke the BASH environment by typing:\n    \"bash $THIS_FILE\"\nat the command line prompt (without the quotation marks).\n\n          >>> Now exiting script <<<"
         #
         f_abort $1
      fi
      #
}  # End of function f_test_dash
#
# +----------------------------------------+
# |         Function f_test_connect_TEMPLATE        |
# +----------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#    Uses: None.
# Outputs: None.
#
# Summary: Test the internet connection by pinging IP address 8.8.8.8.
#
# Dependencies: f_test_connection.
#
# PLEASE NOTE: RENAME THIS FUNCTION WITHOUT SUFFIX "_TEMPLATE" AND COPY
#              THIS FUNCTION INTO ANY SCRIPT WHICH DEPENDS ON THE
#              LIBRARY FILE "common_bash_function.lib".
#
f_test_connect_TEMPLATE () {
      #
      # Test network connection to IP address or web site.
      #
      # Use ping <IP Address> or <URL> <pause secs. to read message>.
      # Examples:
      #f_test_connection 192.168.1.1
      #f_test_connection $1 8.8.8.8 2 (2-second pause to read messages).
      #f_test_connection $1 www.dropbox.com 1 (1-second pause to read messages).
      #
      f_test_connection $1 8.8.8.8 1
      #
}  # End of function f_test_connect
#
# +----------------------------------------+
# |        Function f_test_connection      |
# +----------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - Network name of server, IP address, or web site address (URL).
#          $3 - Pause n seconds to read message (Optional).
#    Uses: None.
# Outputs: ERROR.
#
# Summary: Test network connection using provided LAN or IP address, web site.
#
# Dependencies: f_message.
#
f_test_connection () {
      #
      # Check if there is an internet connection before doing a download.
      ping -c 1 -q $2 > /dev/null # Ping server address. All output goes to /dev/null.
      ERROR=$?
      if [ $ERROR -ne 0 ] ; then
         f_message $1 "NOK" "Ping Test Network Connection" " \n\Z1\Zb  No network connection to $2.\Zn" $3
      else
         f_message $1 "NOK" "Ping Test Network Connection" "Network connnection to $2 is good." $3
      fi
      #
      clear # Blank the screen.
      #
}  # End of function f_test_connection.
#
# +----------------------------------------+
# |           Function f_username          |
# +----------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - USERNAME (default or "n" for none. One word without spaces).
#          $3 - String (server and/or mount-point) used in prompt.
#                  (String must begin and end with double-quotes if it includes spaces).
#                  or must have underscores substituting for spaces).
#    Uses: $TEMP_FILE, ANS.
# Outputs: SMBUSER, ERROR.
#
# Summary: Prompt to enter user name.
#
# Dependencies: None.
#
f_username() {
      #
      # Format string, substitute spaces for underscores.
      PRINT_STRING3=$(echo $3 | tr "_" " ")
      #
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
      ERROR=0
      #
      case $1 in
           dialog | whiptail)
              $1 --title "User name for $PRINT_STRING3" --inputbox "Enter user name:" 10 50 $2 2>$TEMP_FILE
              ERROR=$?
              ANS=$(cat $TEMP_FILE)
           ;;
           text)
              echo "           --User name for $PRINT_STRING3--"
              echo
              if [ $2 = "n" ] ; then
                 read -p "Enter user name or n=none (n): " ANS
                 echo
              else
                 read -p "Enter user name or n=none ($2): " ANS
                 echo
              fi
           ;;
      esac
      case $ANS in
              "") SMBUSER=$2 ;;
           N | n) SMBUSER="anonymous" ;;
               *) SMBUSER="$ANS" ;;
      esac
      unset ANS
      #
      if [ -z "$SMBUSER" ] ; then
         SMBUSER=$2
      fi
      #
      case $ERROR in
           1) SMBUSER="" ;;   # <Cancel> button pressed.
           255) SMBUSER="" ;; # <ESC> key pressed.
      esac
      #
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      #
      unset PRINT_STRING3
      #
}  # End of function f_username.
#
# +----------------------------------------+
# |           Function f_password          |
# +----------------------------------------+
#
#     Rev: 2022-04-24
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - String (server and/or username) used in prompt.
#                  (String must begin and end with double-quotes if it includes spaces).
#                  or must have underscores substituting for spaces).
#    Uses: TEMP_FILE.
# Outputs: PASSWORD, ERROR.
#
# Summary: Prompt to enter password.
#
# Dependencies: None.
#
f_password() {
      #
      # Format string, substitute spaces for underscores.
      PRINT_STRING2=$(echo $2 | tr "_" " ")
      #
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
      PASSWORD=""
      #
      case $1 in
           dialog)
              $1 --title "Password for $PRINT_STRING2" --clear --insecure --passwordbox "Enter SMB password for $PRINT_STRING2:" 10 70 2>$TEMP_FILE
              ERROR=$?
              PASSWORD=$(cat $TEMP_FILE)
              #
              if [ -r  $TEMP_FILE ] ; then
                 rm  $TEMP_FILE
              fi
           ;;
           whiptail)
              $1 --title "Password for $PRINT_STRING2" --clear --passwordbox "Enter SMB password for $PRINT_STRING2:" 10 70 2>$TEMP_FILE
              ERROR=$?
              PASSWORD=$(cat $TEMP_FILE)
              #
              if [ -r  $TEMP_FILE ] ; then
                 rm  $TEMP_FILE
              fi
           ;;
           text)
              echo
              echo "To [Cancel] press \"Enter\" key."
              read -s -p "Enter Password for $PRINT_STRING2: " PASSWORD
              echo
           ;;
      esac
      #
      case $ERROR in
           1) PASSWORD="" ;;   # <Cancel> button pressed.
           255) PASSWORD="" ;; # <ESC> key pressed.
      esac
      #
      if [ -r  $TEMP_FILE ] ; then
         rm  $TEMP_FILE
      fi
      #
      unset PRINT_STRING2
      #
}  # End of function f_password.
#
# +----------------------------------------+
# |      Function f_bad_sudo_password      |
# +----------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#    Uses: None.
# Outputs: None.
#
# Summary: Display an error message when a bad Sudo password is entered.
#
# Dependencies: f_message.
#
f_bad_sudo_password () {
      #
      f_message $1 "NOK" "Incorrect Sudo password" "\n\Z1\ZbWrong Sudo password. Cannot upgrade software.\Zn"
      #
      clear # Blank the screen.
      #
}  # End of function f_bad_sudo_password.
#
# +----------------------------------------+
# | Function f_press_enter_key_to_continue |
# +----------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: None.
#    Uses: X.
# Outputs: None.
#
# Summary: Pause display and Display message: Press 'Enter' key to continue.
#
# Dependencies: None.
#
f_press_enter_key_to_continue () {
      #
      # Display message and wait for user input.
      echo
      echo -n "Press '"Enter"' key to continue."
      read X
      unset X  # Throw out this variable.
      #
}  # End of function f_press_enter_key_to_continue.
#
# +----------------------------------------+
# |         Function f_exit_script         |
# +----------------------------------------+
#
#     Rev: 2022-07-24
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#    Uses: None.
# Outputs: None.
#
# Summary: Display message and exit script with status 0.
#
# Dependencies: f_message.
#
f_exit_script () {
      #
      f_message $1 "NOK" "End of script" "Exiting script now."
      #
      if [ -r  $TEMP_FILE ] ; then
         rm  $TEMP_FILE
      fi
      #
      # Blank the screen. Nicer ending especially if you chose custom colors for this script.
      clear
      #
      exit 0
}  # End of function f_exit_script
#
# +----------------------------------------+
# |              Function f_abort          |
# +----------------------------------------+
#
#     Rev: 2022-07-24
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#    Uses: None.
# Outputs: None.
#
# Summary: Display message and exit with status 1 (error).
#
# Dependencies: f_message.
#
f_abort () {
      #
      # Temporary file has \Z commands embedded for red bold font.
      #
      # \Z commands are used by Dialog to change font attributes
      # such as color, bold/normal.
      #
      # A single string is used with echo -e \Z1\Zb\Zn commands
      # and output as a single line of string wit \Zn commands embedded.
      #
      # Single string is neccessary because \Z commands will not be
      # recognized in a temp file containing <CR><LF> multiple lines also.
      #
      f_message $1 "NOK" "Exiting script" " \Z1\ZbAn error occurred, cannot continue. Exiting script.\Zn"
      #
      if [ -r  $TEMP_FILE ] ; then
         rm  $TEMP_FILE
      fi
      #
      # Blank the screen. Nicer ending especially if you chose custom colors for this script.
      clear
      #
      exit 1
      #
}  # End of function f_abort.
#
# +------------------------------------+
# |          Function f_about          |
# +------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "NOK", "OK", or null [OPTIONAL] to control display of "OK" button.
#          $3 - Pause $3 seconds [OPTIONAL]. If "NOK" then pause to allow text to be read.
#          THIS_DIR, THIS_FILE, VERSION.
#    Uses: DELIM.
# Outputs: None.
#
# Summary: Display a Brief Description of a script by showing any text lines
#           beginning with "#&".
#
# Dependencies: f_display_common.
#
f_about () {
      #
      # Display text (all lines beginning ("^") with "#& " but do not print "#& ").
      # sed substitutes null for "#& " at the beginning of each line
      # so it is not printed.
      DELIM="^#&"
      f_display_common $1 $DELIM $2 $3
      #
}  # End of f_about.
#
# +------------------------------------+
# |      Function f_code_history       |
# +------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "NOK", "OK", or null [OPTIONAL] to control display of "OK" button.
#          $3 - Pause $3 seconds [OPTIONAL]. If "NOK" then pause to allow text to be read.
#          THIS_DIR, THIS_FILE, VERSION.
#    Uses: DELIM.
# Outputs: None.
#
# Summary: Display the code history of a script by showing any text lines
#           beginning with "##".
#
# Dependencies: f_display_common.
#
f_code_history () {
      #
      # Display text (all lines beginning ("^") with "##" but do not print "##").
      # sed substitutes null for "##" at the beginning of each line
      # so it is not printed.
      DELIM="^##"
      f_display_common $1 $DELIM $2 $3
      #
}  # End of function f_code_history.
#
# +------------------------------------+
# |      Function f_help_message       |
# +------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "NOK", "OK", or null [OPTIONAL] to control display of "OK" button.
#          $3 - Pause $3 seconds [OPTIONAL]. If "NOK" then pause to allow text to be read.
#          THIS_DIR, THIS_FILE, VERSION.
#    Uses: DELIM.
# Outputs: None.
#
# Summary: Display the help message of a script by showing any text lines
#           beginning with "#?".
#
# Dependencies: f_display_common.
#
f_help_message () {
      #
      # Display text (all lines beginning ("^") with "#?" but do not print "#?").
      # sed substitutes null for "#?" at the beginning of each line
      # so it is not printed.
      DELIM="^#?"
      f_display_common $1 $DELIM $2 $3
      #
}  # End of f_help_message.
#
# +----------------------------------------+
# |      Function f_show_mount_points      |
# +----------------------------------------+
#
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $THIS_FILE,
#    Uses: X, Y, ERROR, $TEMP_FILE.
# Outputs: None.
#
# Summary: Display the mount-points and local devices.
#
# Dependencies: df, grep, lsblk, f_message.
#
f_show_mount_points () {
      #
      # Blank the screen.
      clear
      #
      echo "Local PC is "$HOSTNAME"." >$TEMP_FILE
      echo "------------------------------------------------------------------" >>$TEMP_FILE
      echo "Display status of any shared directories from remote file servers." >>$TEMP_FILE
      echo "------------------------------------------------------------------" >>$TEMP_FILE
      #
      # Note: The applications "df" and "findmnt" can show the same
      #       formatted information using certain optional parameters.
      #       Using "findmnt" without the --df will display a tree-like format
      #       of the file systems.
      #
      # Example:
      # These will display identical formatted information.
      # df --all --human-readable --output=source,size,avail,target | grep /media/
      # findmnt --all --df --output=source,size,avail,target | grep /media/
      #
      # Example:
      # Application "findmnt" will display a tree-like format of the file systems.
      # Below will include both the mounted native disk along with the mounted
      # block devices (USB or external drives).
      # findmnt --all --output=source,size,avail,target | head -n 2
      # findmnt --all --output=source,size,avail,target | grep /media/
      #
      # Application "df" will display the same information but without the tree.
      # df --all --human-readable --output=source,size,avail,target | head -n 1
      # df --all --human-readable --output=source,size,avail,target | grep /media/
      #
      # Test if this version of "df" has these OPTIONS.
      df --all --human-readable --output=source,avail,target >/dev/null 2>&1
      ERROR=$?
      #
      if [ $ERROR -eq 1 ] ; then
         # Older version of "df" or nothing mounted, so use df with minimal OPTIONS.
         # Use traditional display of data.
         # Get df column header line.
         DF_CMD_HEAD_1="df --all --human-readable | head -n 1 >>$TEMP_FILE  2>&1"
         #
         # Get /mnt/ file server mount-points
         DF_CMD_1="df --all --human-readable | grep "//" >>$TEMP_FILE 2>&1"
         #
         # Now display information for local block devices i.e. USB drives, etc.
         # Get df column header line.
         DF_CMD_HEAD_2="df --all --human-readable | head -n 1 >>$TEMP_FILE  2>&1"
         #
         # Get /media/ local devices mount-points.
         DF_CMD_2="df --all --human-readable | grep -e /media/ -e /md >>$TEMP_FILE 2>&1"
      else
         # Newer version of "df" in use.
         # Use simplifed display of data.
         # Get df column header line.
         DF_CMD_HEAD_1="df --all --human-readable --output=source,size,avail,target | head -n 1 >>$TEMP_FILE"
         #
         # Get /mnt/ file server mount-points
         DF_CMD_1="df --all --human-readable --output=source,size,avail,target | grep /mnt/ >>$TEMP_FILE"
         #
         # Now display information for local block devices i.e. USB drives, etc.
         # Get df column header line.
         DF_CMD_HEAD_2="df --all --human-readable --output=source,size,used,avail,target | head -n 1 >>$TEMP_FILE"
         #
         # Get /media/ local devices mount-points.
         DF_CMD_2="df --all --human-readable --output=source,size,used,avail,target | grep -e /media/ -e /md >>$TEMP_FILE"
      fi
      #
      # Get df column header line.
      eval $DF_CMD_HEAD_1
      #
      # Get /mnt/ file server mount-points
      eval $DF_CMD_1
      ERROR=$?
      #
      # Are there any file server share-points mounted on /mnt/?
      if [ $ERROR -eq 0 ] ; then
         # Yes, remote file server share-points mounted.
         echo >>$TEMP_FILE
         # Get username, mounted file server share-point, mount-point information from /etc/mtab.
         grep "//" /etc/mtab | awk -F "," '{ print $1,$5 }' | awk '{ print $5" mounted "$1." on "$2}' >>$TEMP_FILE
         echo >>$TEMP_FILE
      else
         # No, remote file server share-points not mounted.
         echo "N/A             N/A   N/A  No remote server mounted" >>$TEMP_FILE
         echo >>$TEMP_FILE
      fi
      #
      echo "----------------------------------------------------------------------" >>$TEMP_FILE
      echo "Display status of any mounted local block devices i.e. USB drives etc." >>$TEMP_FILE
      echo "----------------------------------------------------------------------" >>$TEMP_FILE
      # Now display information for local block devices i.e. USB drives, etc.
      # Get df column header line.
      eval $DF_CMD_HEAD_2
      #
      # Get /media/ local devices mount-points.
      eval $DF_CMD_2
      ERROR=$?
      #
      # Are there any local block devices mounted on /media/?
      if [ $ERROR -eq 1 ] ; then
         # No, local block devices not mounted.
         echo "N/A             N/A   N/A  No local block devices mounted" >>$TEMP_FILE
         echo >>$TEMP_FILE
      fi
      #
      echo >>$TEMP_FILE
      echo "------------------------------------------------------------" >>$TEMP_FILE
      echo "List all recognized local block devices i.e. USB drives etc." >>$TEMP_FILE
      echo "------------------------------------------------------------" >>$TEMP_FILE
      #
      # Print /dev/sd[a-z][1-9] i.e. "/dev/sdb1" block devices HDDs, SSDs, USB drives
      # using the lsblk command with only necessary columns displayed.
      #
      # Print column header line
      # awk 'BEGIN { print "DEVICE  SIZE   FSTYPE             MOUNTPOINT" }' >>$TEMP_FILE
      echo "NAME    SIZE   USED     USE%   AVAIL    FSTYPE   MOUNTPOINT" >>$TEMP_FILE
      #
      # Print filtered results of command lsblk.
      # Use --tree to relate RAID md devices to RAID member drive devices.
      #
      # Easier to read information on RAID devices.
      lsblk -fs --tree --output NAME,SIZE,FSUSED,FSUSE%,FSAVAIL,FSTYPE,MOUNTPOINT | grep -e sd[a-z][1-9] -e md | awk  '{ printf "%-7s %-6s %-8s %-6s %-8s %-8s %s\n", $1,$2,$3,$4,$5,$6,$7 }' >>$TEMP_FILE
      #
      # Display results.
      f_message $1 "OK" "(use arrow keys to scroll up/down/side-ways)" $TEMP_FILE
      #
      # Delete temporary file.
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      #
      # Throw out these variables.
      unset X Y ERROR
      #
}  # End of function f_show_mount_points.
#
# +----------------------------------------+
# |         Function f_file_manager        |
# +----------------------------------------+
#
#     Rev: 2022-04-08
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - TARGET_DIR.
#                  (String must either begin and end with double-quotes
#                  or must not include spaces but must have underscores substituting for spaces).
#          $3 - [Optional] Foreground/Background process flag.
#               1 or null - Run file manager as a foreground process.
#               2 - Run file manager as a Background process.
#    Uses: FILE_MGR FILE_MGR_APPS.
# Outputs: ERROR, RUNAPP.
#
# Summary: Detect file manager application and run it on the $2 Directory.
#
# Dependencies: f_message.
#
f_file_manager () {
      #
      # Initialize variable.
      RUNAPP=0
      #
      # Detect the environment (CLI or X-Windows) then run the preferred
      # file manager appropriate for the current environment.
      #
      #   +--------------------------------------------------------------+
      #   | Determine what environment is in use, pure CLI or X-Windows? |
      #   +--------------------------------------------------------------+
      # Determine if user is in a pure CLI environment
      # or if using a CLI within an X-Window on a GUI Desktop.
      #
      # Set XWIN equal to the value of $DISPLAY.
      XWIN=$(echo $DISPLAY)
      #
      # $DISPLAY is null if in a pure CLI environment.
      # $DISPLAY is not null then in an X-Window environment.
      #
      # In an X-Window environment:
      # Format of $DISPLAY is: <hostname>:<Display number>.<Screen number>
      #
      # If on local PC (localhost) in X-Windows then <hostname> is null.
      # i.e. ":0" or ":0.0"
      #
      # If on a remote file server "Mainfileserver" in X-Windows then:
      # i.e. "Mainfileserver:0" or "Mainfileserver:0.1"
      #
      #
      #================================================================================
      # EDIT $FILE_MGR_APPS BELOW TO INCLUDE APPS FOR EITHER X-WINDOWS OR CLI.
      # THE FILE MANAGER APPS APPS ARE LISTED IN THE ORDER OF PREFERENCE, FIRST APP IS
      # FIRST USED (IF INSTALLED). IF NOT INSTALLED, THE FOR-LOOP WILL TRY THE NEXT APP.
      #================================================================================
      #
      #
      # Is the environment a pure CLI environment?
      if [ -z $XWIN ] ; then
         # Yes, a pure CLI environment so use only CLI file manager apps.
         # List file managers in preferred order with most preferred first.
         FILE_MGR_APPS="ranger mc nnn vifm"
      else
         # No, it is an X-Window environment so can use both X-Window and CLI file manager apps.
         # List file managers in preferred order with most preferred first.
         FILE_MGR_APPS="pcmanfm pcmanfm-qt caja nemo nautilus konqueror krusader dolphin thunar xfe 4pane"
      fi
      #
      for FILE_MGR in $FILE_MGR_APPS
          do
             if [ $RUNAPP -eq 0 ] ; then
                # Test if $FILEMGR application is installed.
                type $FILE_MGR >/dev/null 2>&1
                ERROR=$?
                #
                # Is application installed.
                if [ $ERROR -eq 0 ] ; then
                   # Yes, application is installed.
                   # Below is How-To exit out of the CLI file managers.
                   case $FILE_MGR in
                        mc)
                           f_message $1 "NOK" "To exit $FILE_MGR" "Type 'exit' to exit out of the $FILE_MGR application.\n\n The application $FILE_MANAGER takes of few seconds to start, please be patient." 0
                        ;;
                        ranger)
                           f_message $1 "NOK" "To exit $FILE_MGR" "Type 'q' or 'q!' to exit out of the $FILE_MGR application."
                        ;;
                        vifm)
                           f_message $1 "NOK" "To exit $FILE_MGR" "Type ':q' to exit out of the $FILE_MGR application."
                        ;;
                        nnn)
                           f_message $1 "NOK" "To exit $FILE_MGR" "Type 'q' to exit out of the $FILE_MGR application."
                        ;;
                   esac
                   #
                   # Run application $FILE_MGR to display $2 target directory.
                   #
                   # Run file manager as a foreground process?
                   if [ "$3" = 2 ] ; then
                      # No, run in background.
                      $FILE_MGR $2 &
                   else
                      # Yes, run in foreground.
                      $FILE_MGR $2
                   fi
                   #
                   ERROR=$?
                   if [ $ERROR -eq 0 ] ; then
                      # Successfully ran file manager. Prevent another file manager from running.
                      RUNAPP=1
                   else
                      # Error when file manager ran.
                      RUNAPP=0
                   fi
                fi
             fi
          done
      #
      # Blank the screen.
      clear
      #
      if [ $RUNAPP -eq 0 ] ; then
         f_message $1 "OK" "File Manager Error" "\nA File Manager was not automatically detected or not installed."
      fi
      #
      # Throw out this variable.
      unset FILE_MGR FILE_MGR_APPS
      #
}  # End of function f_file_manager.
#
# +----------------------------------------+
# |         Function f_text_editor         |
# +----------------------------------------+
#
#     Rev: 2022-04-08
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - String "[Description of] File(s)"
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#          $3 - Default directory.
#          $4 - [Optional] File name.
#          $5 - [Optional] Foreground/Background process flag.
#               1 or null - Run file manager as a foreground process.
#               2 - Run file manager as a Background process.
#          THIS_DIR, THIS_FILE.
#    Uses: RUNAPP
# Outputs: ERROR.
#
# Summary: Select a file for editing and then select and use a text editor.
#
# Dependencies: f_message, f_select_file.
#
f_text_editor () {
      #
      FILE_TXT=""
      #
      if [ -e "$4" ] ; then
         ANS=$4
      else
         f_select_file $1 "$2" $3
      fi
      #
      # Set FILE_TXT to the list of selected files.
      FILE_TXT=$ANS
      #
      if [ -n "$FILE_TXT" ] ; then
         # Valid files selected.
         # Format:
         # FILE_TXT="<FILE1> <FILE2>...<FILEn>"
         #
         # Initialize variable.
         RUNAPP=0
         #
         # Detect the environment (CLI or X-Windows) then run the preferred
         # text editor appropriate for the current environment.
         #
         #   +--------------------------------------------------------------+
         #   | Determine what environment is in use, pure CLI or X-Windows? |
         #   +--------------------------------------------------------------+
         # Determine if user is in a pure CLI environment
         # or if using a CLI within an X-Window on a GUI Desktop.
         #
         # Set XWIN equal to the value of $DISPLAY.
         XWIN=$(echo $DISPLAY)
         #
         # $DISPLAY is null if in a pure CLI environment.
         # $DISPLAY is not null then in an X-Window environment.
         #
         # In an X-Window environment:
         # Format of $DISPLAY is: <hostname>:<Display number>.<Screen number>
         #
         # If on local PC (localhost) in X-Windows then <hostname> is null.
         # i.e. ":0" or ":0.0"
         #
         # If on a remote file server "Mainfileserver" in X-Windows then:
         # i.e. "Mainfileserver:0" or "Mainfileserver:0.1"
         #
         #
         #================================================================================
         # EDIT $TEXT_EDITOR_APPS BELOW TO INCLUDE APPS FOR EITHER X-WINDOWS OR CLI.
         # THE TEXT EDITOR APPS ARE LISTED IN THE ORDER OF PREFERENCE, FIRST APP IS FIRST
         # USED (IF INSTALLED). IF NOT INSTALLED, THE FOR-LOOP WILL TRY THE NEXT APP.
         #================================================================================
         #
         #
         # Is the environment a pure CLI environment?
         if [ -z $XWIN ] ; then
            # Yes, a pure CLI environment so use only CLI file manager apps.
            # List file managers in preferred order with most preferred first.
            TEXT_EDITOR_APPS="nano jed joe emacs ed vim vi"
         else
            # No, it is an X-Window environment so can use both X-Window and CLI file manager apps.
            # List file managers in preferred order with most preferred first.
            TEXT_EDITOR_APPS="xed gedit kedit pluma mousepad nano"
         fi
         #
         for TEXT_EDITOR in $TEXT_EDITOR_APPS
             do
                if [ "$RUNAPP" -eq 0 ] ; then
                   # Test if $TEXT_EDITOR application is installed.
                   type $TEXT_EDITOR >/dev/null 2>&1
                   ERROR=$?
                   if [ "$ERROR" -eq 0 ] ; then
                      # Opening text editor to allow editing.
                      #
                      # Run application $TEXT_EDITOR to open document $FILE_TEXT.
                      #
                      # Run text editor as a foreground process?
                      if [ "$5" = 2 ] ; then
                         # No, run in background.
                         $TEXT_EDITOR $FILE_TXT &
                      else
                         # Yes, run in foreground.
                         $TEXT_EDITOR $FILE_TXT
                      fi
                      #
                      ERROR=$?
                      if [ $ERROR -eq 0 ] ; then
                         # Successfully ran text editor. Prevent another file manager from running.
                         RUNAPP=1
                      else
                         # Error when file manager ran.
                         RUNAPP=0
                      fi
                   fi
                fi
             done
         #
         if [ "$RUNAPP" -eq 0 ] ; then
            f_message $1 "OK" "Text Editor Error" "Text editor was not automatically detected."
         fi
         #
         unset RUNAPP TEXT_EDITOR TEXT_EDITOR_APPS
      fi
      #
}  # End of function f_text_editor.
#
# +----------------------------------------+
# |          Function f_web_browser        |
# +----------------------------------------+
#
#     Rev: 2023-08-07
#  Inputs: $1=GUI
#    Uses: WEB_BROWSER_FOUND, WEB_BROWSER_APPS.
# Outputs: WEB_BROWSER, RUNAPP, ERROR.
#
# Summary: Detect web browser application.
#
# Dependencies: f_message.
#
f_web_browser () {
      #
      #   +--------------------------------------------------------------+
      #   | Determine what environment is in use, pure CLI or X-Windows? |
      #   +--------------------------------------------------------------+
      # Determine if user is in a pure CLI environment
      # or if using a CLI within an X-Window on a GUI Desktop.
      #
      # Set XWIN equal to the value of $DISPLAY.
      XWIN=$(echo $DISPLAY)
      #
      # $DISPLAY is null if in a pure CLI environment.
      # $DISPLAY is not null then in an X-Window environment.
      #
      # In an X-Window environment:
      # Format of $DISPLAY is: <hostname>:<Display number>.<Screen number>
      #
      # If on local PC (localhost) in X-Windows then <hostname> is null.
      # i.e. ":0" or ":0.0"
      #
      # If on a remote file server "Mainfileserver" in X-Windows then:
      # i.e. "Mainfileserver:0" or "Mainfileserver:0.1"
      #
      # Is the environment a pure CLI environment?
      if [ -z $XWIN ] ; then
         # Yes, a pure CLI environment so use only CLI file manager apps.
         # List web browsers in preferred order with most preferred first.
         #
         #
         #================================================================================
         # EDIT $WEB_BROWSER_APPS BELOW TO LIST FAVORITE WEB BROWSER APPS FOR CLI.
         # THE WEB BROWSER APPS ARE LISTED IN THE ORDER OF PREFERENCE.
         # THE FIRST APP IN THE LIST IS THE ONE FIRST USED (IF INSTALLED).
         # IF NOT INSTALLED, THE FOR-LOOP WILL TRY THE NEXT APP.
         #================================================================================
         #
         #
         WEB_BROWSER_APPS="links2 links elinks w3m "
      else
         # No, it is an X-Window environment so can use both X-Window and CLI file manager apps.
         # List web browsers in preferred order with most preferred first.
         #
         #
         #================================================================================
         # EDIT $WEB_BROWSER_APPS BELOW TO LIST FAVORITE WEB BROWSER APPS FOR X-WINDOWS.
         # THE WEB BROWSER APPS ARE LISTED IN THE ORDER OF PREFERENCE.
         # THE FIRST APP IN THE LIST IS THE ONE FIRST USED (IF INSTALLED).
         # IF NOT INSTALLED, THE FOR-LOOP WILL TRY THE NEXT APP.
         #================================================================================
         #
         #
         WEB_BROWSER_APPS="chromium chromium-browser google-chrome google-chrome-stable firefox opera vivaldi"
      fi
      #
      # Detect installed web browser (in order of preference).
      #
      # Initialize variables.
      RUNAPP=0
      #
      for WEB_BROWSER in $WEB_BROWSER_APPS
          do
             # Is $WEB_BROWSER application is installed?
             if [ $RUNAPP -eq 0 ] ; then
                type $WEB_BROWSER >/dev/null 2>&1
                ERROR=$?
                #
                # Is $WEB_BROWSER installed?
                if [ $ERROR -eq 0 ] ; then
                   # Yes, installed.
                   RUNAPP=1
                   WEB_BROWSER_FOUND=$WEB_BROWSER
                fi
             fi
          done
      #
      # Was a web browser detected?
      # For-loop outputs $WEB_BROWSER_FOUND.
      if [ $RUNAPP -eq 1 ] ; then
         # Set output to $WEB_BROWSER.
         WEB_BROWSER=$WEB_BROWSER_FOUND
      else
         f_message $1 "OK" "Web Browser Error" "\nWeb browser was not automatically detected."
      fi
      #
      unset WEB_BROWSER_FOUND WEB_BROWSER_APPS
      #
}  # End of function f_web_browser.
#
# +----------------------------------------+
# |          Function f_select_dir         |
# +----------------------------------------+
#
#     Rev: 2023-12-29
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - String "[Description] Directory".
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#                  !!! String cannot be longer than 28 characters !!!
#          $3 - Default parent directory.
#          $4 - [Optional] 1/0 1=Select only one directory
#                            0 or null=Select multiple directories.
#          THIS_DIR.
#    Uses: TEMP_FILE2, ANS, ERROR, SCRIPT_LIST.
# Outputs: ANS (List of selected directories delimited by spaces)
#              Note: A selected directory does not include a trailing "/" forward-slash.
#          ERROR.
#
# Summary: Prompt user-entered file name.
#
# Dependencies: f_yn_question, f_message.
#
f_select_dir () {
      #
      # Initialize variable DEFAULT_DIR to passed argument base directory.
      DEFAULT_DIR=$3
      #
      # Format string, substitute spaces for underscores.
      DIR_DESCR=$(echo $2 | tr "_" " ")
      #
      TEMP_FILE2=$THIS_DIR/$THIS_FILE"_temp2.txt"
      #
      # Delete TEMP_FILE2.
      if [ -e "$TEMP_FILE2" ] ; then
         rm $TEMP_FILE2
      fi
      #
      case $1 in
           dialog)
              # Is the length of $DIR_DESCR String longer than 28 characters?
              # Truncate string length so Dialog f_select works on an 80x24 character VGA display.
              #DIR_DESCR=${DIR_DESCR:0:28}
              #
              # Initialize variables.
              DIR_SELECTED=""
              ANS=""
              #
              # Reset ERROR for while-loop to work.
              ERROR=0
              #
              while [ "$ERROR" -eq 0 ]
                    do
                       # During the While-Loop, this allows for dynamic
                       # resizing of the  Dialog directory selector if the
                       # user re-sizes the X-window to see more files.
                       #
                       # Get the screen resolution or X-window size.
                       # Get rows (height).
                       YSCREEN=$(stty size | awk '{ print $1 }')
                       Y=$YSCREEN
                       #
                       # Limit Dialog box to 240x72 characters across x lines.
                       if [ $Y -gt 72 ] ; then
                          Y=72
                       fi
                       #
                       if [ $Y -ge 28  ] ; then
                          # Padding is 4, around Dialog --deselect box.
                          let Y=$Y-4
                       fi
                       #
                       # Get columns (width).
                       XSCREEN=$(stty size | awk '{ print $2 }')
                       X=$XSCREEN
                       #
                       # Limit Dialog box to 240x72 characters across x lines.
                       if [ $X -gt 240 ] ; then
                          X=240
                       fi
                       #
                       if [ $X -ge 84  ] ; then
                          # Padding is 4, around Dialog --deselect box.
                          let X=$X-4
                       fi
                       #
                       # The dialog --dselect --backtitle "Please choose $DIR_DESCR"
                       # will only display if screen/window resolution is at least 30 lines vertically.
                       # If less than 30 lines, the directory browser --dselect
                       # will still be displayed but without the --backtitle.
                       #
                       # If number of lines exceeds screen/window height then set textbox height.
                       # If window size is less than 80 x 24, then Dialog f_select_dir will not work properly.
                       if [ $YSCREEN -lt 24 ] || [ $XSCREEN -lt 80 ] ; then
                          f_message $1 "OK" "Window Size too Small" "\nThis window is too small at $XSCREEN x $YSCREEN.\n\nThe minimum window size is 80 characters x 24 lines but preferably at least 120x40.\n\nPlease increase the window size now."
                       fi
                       #
                       DIR_SELECTED=$($1 --stdout --title "Use <tab>, <up/down arrows> and <spacebar> to select a $DIR_DESCR." --backtitle "Please choose $DIR_DESCR" --ok-label "Choose $DIR_DESCR" --cancel-label "Done choosing" --dselect "$DEFAULT_DIR" $Y $X)
                       ERROR=$?
                       #
                       # From man dialog page.
                       # Exit status is subject to being overridden by environment variables.
                       # The default values and corresponding environment variables that can override them are:
                       #
                       # 0    if the YES or OK button is pressed (DIALOG_OK).
                       #
                       # 1    if the No or Cancel button is pressed (DIALOG_CANCEL).
                       #
                       # 2    if the Help button is pressed (DIALOG_HELP),
                       #      except as noted below about DIALOG_ITEM_HELP.
                       #
                       # 3    if the Extra button is pressed (DIALOG_EXTRA).
                       #
                       # 4    if the Help button is pressed,
                       #      and the --item-help option is set
                       #      and the DIALOG_ITEM_HELP environment variable is set to 4.
                       #
                       #      While any of the exit-codes can be overridden using
                       #      environment variables, this special case was introduced
                       #      in 2004 to simplify compatibility.
                       #
                       #      Dialog uses DIALOG_ITEM_HELP(4)  internally,  but  unless  the  environment
                       #      variable is also set, it changes that to DIALOG_HELP(2) on exit.
                       #
                       # -1   if errors occur inside dialog (DIALOG_ERROR) or dialog exits because the ESC key (DIALOG_ESC) was pressed.
                       #
                       # Confirm directory selection.
                       f_select_dir_verify $1 "$DIR_DESCR" "$DIR_SELECTED" "$3" "$4"
                    done
              #
              # Reset ERROR since on exiting WHILE-loop it will always be EXIT=1.
              ERROR=0
              #
           ;;
           whiptail | text)
              #
              # Delete TEMP_FILE2.
              if [ -e "$TEMP_FILE2" ] ; then
                 rm $TEMP_FILE2
              fi
              #
              # Reset ERROR for while-loop to work.
              ERROR=0
              #
              # Check if application "fzf" is installed.
              type fzf >/dev/null 2>&1
              ERROR=$?
              #
              # Is "fzf" installed?
              if [ $ERROR -eq 0 ] ; then
                 # Yes, "fzf" is installed.
                 #
                 # fzf EXIT STATUS
                 #       0      Normal exit
                 #       1      No match
                 #       2      Error
                 #       130    Interrupted with CTRL-C or ESC
                 #
                 f_message $1 "OK" "$DIR_DESCR" "At the next prompt, select the desired directory name\nby typing the first few letters of the name and using the up-down arrows.\n\nPress [ Enter ] key to select directory name.\n\nPress [ Esc ] key or [ Ctrl+C ] to EXIT or CANCEL selection."
                 #
                 # Initialize ERROR for While-loop.
                 ERROR=0
                 #
                 while [ "$ERROR" -eq 0 ]
                       do
                          # Application "fzf" limitation is you can only select sub-directories
                          # of the default directory during the While-loop.
                          # You cannot select a different parent directory from the default directory.
                          # i.e. if you select a file from "/home/user/Documents"
                          #      then you cannot select a file from "/home/user/Downloads",
                          #      but you could select a file from "/home/user/Documents/unread"
                          #
                          # Use $3 instead of $DEFAULT_DIRECTORY as the latter may change.
                          f_select_dir_fzf $1 "$DIR_DESCR" "$3" "$4"
                          #
                       done
              else
                 # No, "fzf" is not installed.
                 #
                 # Only a single file name to select?
                 # User-input via text free-form directory name entry.
                 # Initialize variables.
                 DIR_SELECTED=""
                 ANS=""
                 #
                 # Reset ERROR for while-loop to work.
                 ERROR=0
                 #
                 while [ "$ERROR" -eq 0 ]
                       do
                          # The user-entered directory name is whatever is after $3 default parent directory.
                          f_ask_question $1 "User-entered $DIR_DESCR name" "Enter $DIR_DESCR name(s) with full path:" "$DEFAULT_DIR"
                          DIR_SELECTED="$ANS"
                          #
                          # Confirm directory selection.
                          f_select_dir_verify $1 "$DIR_DESCR" "$DIR_SELECTED" $4
                       done
                 #
                 # Reset ERROR since on exiting WHILE-loop it will always be EXIT=1.
                 ERROR=0
              fi
           ;;
      esac
      #
      # Were there any directories selected?
      # TEMP_FILE2 is only created by f_select_dir_verify when directories are selected.
      if [ -e "$TEMP_FILE2" ] ; then
         # Yes, directories were selected.
         #
         # Select only a single directory?
         if [ "$4" = 1 ] ; then
            # Yes, a single directory has been selected
            ANS=$(cat $TEMP_FILE2)
         else
            # No, multiple directories were seleceted.
            # Convert single-column list of file names contained in temp file
            # to single string of file names delimited by space.
            #
            TEMP_FILE3=$TEMP_FILE2"_temp3.txt"
            #
            while read LINE
                  do
                     echo -n $LINE" " >> $TEMP_FILE3
                  done < $TEMP_FILE2
            #
            ANS=$(cat $TEMP_FILE3)
         fi
      else
         # No, directories were not selected.
         ANS=""
         ERROR=1
      fi
      #
      if [ -e "$TEMP_FILE" ] ; then
         rm $TEMP_FILE
      fi
      #
      if [ -e "$TEMP_FILE2" ] ; then
         rm $TEMP_FILE2
      fi
      #
      if [ -e "$TEMP_FILE3" ] ; then
         rm $TEMP_FILE3
      fi
      #
      if [ "$ERROR" -eq 1 ] ; then
         # Return to previous calling function.
         return 1
      else
         return 0
      fi
      #
}  # End of function f_select_dir.
#
# +----------------------------------------+
# |        Function f_select_dir_fzf       |
# +----------------------------------------+
#
#     Rev: 2023-12-29
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - String "[Description] Directory".
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#                  !!! String cannot be longer than 28 characters !!!
#          $3 - Original Default directory.
#          $4 - [Optional] 1/0 1=Select only one directory
#                            0 or null=Select multiple directories.
#          THIS_DIR.
#    Uses: None.
# Outputs: TEMP_FILE2 (List of selected directories delimited by spaces)
#          ERROR.
#
# Summary: Used in f_select_dir while-loop. Confirm a directory exists or if not create it.
#
# Dependencies: f_yn_question, f_message.
#
f_select_dir_fzf () {
      #
      # Initialize variables.
      DIR_DESCR=$2
      DEFAULT_DIR=$3
      # Set DIR_OLD to DEFAULT_DIR so that fzf starts at DEFAULT_DIR.
      DIR_OLD=$3
      #
      # fzf EXIT STATUS
      #       0      Normal exit
      #       1      No match
      #       2      Error
      #       130    Interrupted with CTRL-C or ESC
      #
      while [ "$ERROR" -eq 0 ]
            do
               # The DEFAULT_DIR will change to the sub-directory selected during each loop in the while-loop.
               # If the user aborts the selection or wants to select another sub-directory,
               # then DEFAULT_DIR is set to $3 by f_select_dir_verify to start over from the original directory.
               DIR_SELECTED=$(find $DIR_OLD -maxdepth 1 -type d 2>/dev/null | fzf --query="^$DEFAULT_DIR" --pointer="=>" --prompt "Type file name and use up-down arrows. Esc key to skip. Select: ")
               ERROR=$?
               #
               if [ "$ERROR" -eq 0 ] ; then
                  # Is directory selection done?
                  if [ "$DIR_SELECTED" = "$DIR_OLD" ] ; then
                     # Yes, final directory selection is made.
                     if [ -n $DIR_SELECTED ] ; then
                        # Verify each file selected $FILE_SELECTED and append to file TEMP_FILE2.
                        f_select_dir_verify $1 "$2" "$DIR_SELECTED" $3 $4
                        # Outputs TEMP_FILE2 which has a list of selected file names in a single column.
                        # Outputs ERROR=1 if selecting only 1 directory (not multiple directories).
                     fi
                  else
                     DIR_OLD=$DIR_SELECTED
                     DEFAULT_DIR=$DIR_SELECTED
                  fi
               fi
            done
      #
      # If user pressed [Ctrl-C] or [Esc] key,
      # then ERROR=130 and DIR_SELECTED="".
      #
}  # End of function f_select_dir_fzf.
#
# +----------------------------------------+
# |      Function f_select_dir_verify      |
# +----------------------------------------+
#
#     Rev: 2023-12-29
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - String "[Description] Directory".
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#                  !!! String cannot be longer than 28 characters !!!
#          $3 - Selected directory.
#          $4 - Original Default directory.
#          $5 - [Optional] 1/0 1=Select only one directory
#                            0 or null=Select multiple directories.
#          THIS_DIR.
#    Uses: None.
# Outputs: TEMP_FILE2 - Temporary file contains a list of file names.
#                       Example: cat $TEMP_FILE2
#                                DIR1/FILE1
#                                DIR2/FILE2
#                                DIR3/FILE3
#          ERROR.
#
# Summary: Used in f_select_dir while-loop. Confirm a directory exists or if not create it.
#
# Dependencies: f_yn_question, f_message.
#
f_select_dir_verify () {
      #
      # Initialize variables.
      DIR_DESCR=$2
      DIR_SELECTED=$3
      #
      case $1 in
           dialog)
              # Was any directory selected?
              if [ $ERROR -eq 0 ] && [ -n $DIR_SELECTED ] ; then
                 f_yn_question $1 "Y" "Confirm $DIR_DESCR name" "$DIR_DESCR name:\n$DIR_SELECTED\n\nIs the $DIR_DESCR name correct?"
                 #
                 # Is the selected directory name correct?
                 if [ "$ANS" != "1" ] ; then
                    # Yes, $DIR_SELECTED name is correct.
                    #
                    # Does the directory exist?
                    if [ -d "$DIR_SELECTED" ] ; then
                       # Yes, $DIR_SELECTED exists and is correct.
                       # Add selected directory name to list of selected directories in TEMP_FILE2
                       # Delete any trailing forward slash.
                       DIR_SELECTED=$(echo $DIR_SELECTED | sed 's|\/$||')
                       #
                       echo $DIR_SELECTED >> $TEMP_FILE2
                       #
                       # Only select a single directory?
                       if [ "$5" = 1 ] ; then
                          # Yes, a single directory has already been selected
                          # so exit while-loop by setting ERROR=1.
                          ERROR=1
                       else
                          # No, multiple directories can be selected, so continue.
                          f_message $1 "NOK" "Directory Entered" "Directory name accepted. Enter next directory name or press \"Done choosing\" button.\n\n$3" 2
                       fi
                    else
                       # No, $3 does not exist. Create new directory?
                       f_yn_question $1 "N" "Error Directory Missing" "Directory does not exist:\n\nDo you want to create a new empty directory?\n\n$3"
                       #
                       if [ "$ANS" -eq 0 ] ; then
                          # Yes, create directory in user-space without using sudo permissions.
                          mkdir -p $DIR_SELECTED
                          ERROR=$?
                          #
                          if [ $ERROR -ne 0 ] ; then
                             # Error creating directory.
                             f_message $1 "OK" "Error Creating Directory" "Directory $2 cannot be created without sudo permissions.\n\nDirectory is missing:\n\n$3"
                          else
                             # Add selected directory to list of selected directories in TEMP_FILE2
                             # Delete any trailing forward slash.
                             DIR_SELECTED=$(echo $DIR_SELECTED | sed 's|\/$||')
                             #
                             echo $DIR_SELECTED >> $TEMP_FILE2
                          fi
                       else
                          # No, do not create directory.
                          f_message $1 "OK" "Directory not created" "New directory not created.\n\n$3"
                       fi
                    fi
                 fi
                 # No, the $DIR_SELECTED is not correct.
              fi
              # No, a directory was not selected.
           ;;
           whiptail | text)
              # Was any directory selected?
              if [ $ERROR -eq 0 ] && [ -n $DIR_SELECTED ] ; then
                 f_yn_question $1 "Y" "Confirm $DIR_DESCR name" "$DIR_DESCR name:\n$DIR_SELECTED\n\nIs the $DIR_DESCR name correct?"
                 # Yes, a directory was selected.
                 # Is the selected directory name correct?
                 if [ "$ANS" != "1" ] ; then
                    # Yes, $DIR_SELECTED is correct.
                    #
                    # Does the selected directory name exist?
                    if [ -d "$DIR_SELECTED" ] ; then
                       # Yes, add selected directory name to list of selected directories in TEMP_FILE2
                       # Delete any trailing forward slash.
                       DIR_SELECTED=$(echo $DIR_SELECTED | sed 's|\/$||')
                       #
                       echo $DIR_SELECTED >> $TEMP_FILE2
                       #
                       f_message $1 "NOK" "Directory Confirmed" "Directory name accepted.\n\n$DIR_SELECTED\n\n" 2
                    else
                       # No, $DIR_SELECTED does not exist.
                       f_message $1 "OK" "Error Directory Missing" "Directory does not exist:\n\n$DIR_SELECTED"
                    fi
                 else
                    # No, the $DIR_SELECTED is not correct.
                    # Force "fzf" to start over using the original default directory as the parent directory.
                    DIR_OLD=$4
                    DEFAULT_DIR=$4
                 fi
                 # No, a directory was not selected.
              fi
              #
              # Only select a single directory?
              if [ "$5" = 1 ] ; then
                 # Yes, a single directory has already been selected
                 # so exit while-loop by setting ERROR=1.
                 ERROR=1
              else
                 # No, multiple directories can be selected, so continue.
                 f_yn_question $1 "Y" "Continue Selecting" "Select another directory?"
                 #
                 if [ "$ANS" = 1 ] ; then
                    # No, done selecting directories.
                    # Force exit out of while-loop.
                    ERROR=1
                 else
                    # Yes, select another directory.
                    # Force "fzf" to start over using the original default directory as the parent directory.
                    DIR_OLD=$4
                    DEFAULT_DIR=$4
                 fi
              fi
           ;;
      esac
      #
}  # End of function f_select_dir_verify.
#
# +----------------------------------------+
# |         Function f_select_file         |
# +----------------------------------------+
#
#     Rev: 2023-12-29
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - String "[Description] File(s)".
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#                  !!! String cannot be longer than 28 characters !!!
#          $3 - Default directory or Default directory/file name.
#          $4 - [Optional] 1/0 1=Select only one file
#                              0 or null=Select multiple files.
#          THIS_DIR, THIS_FILE.
#    Uses: TEMP_FILE, ANS, ERROR, SCRIPT_LIST.
# Outputs: ANS (List of selected files delimited by spaces: "DIR1/FILE1 DIR2/FILE2 DIR3/FILE3...")
#          ERROR.
#
# Summary: Prompt user-entered file name.
#          Dialog UI uses "dialog --fselect".
#          Whiptail/Text UI uses "find" piped to "fzf" to find/select all regular files excluding hidden files.
#                           with commented out command to find/select all regular files including hidden files.
#
# Dependencies: f_yn_question, f_message.
#
f_select_file () {
      #
      # Initialize variable DEFAULT_DIR to passed argument base directory.
      DEFAULT_DIR="$3"
      #
      TEMP_FILE2=$THIS_DIR/$THIS_FILE"_temp2.txt"
      #
      # Format string, substitute spaces for underscores.
      FILE_DESCR=$(echo "$2" | tr "_" " ")
      #
      case $1 in
           dialog)
              #
              # Delete TEMP_FILE2.
              if [ -e "$TEMP_FILE2" ] ; then
                 rm $TEMP_FILE2
              fi
              #
              # Initialize variables.
              FILE_SELECTED=""
              ANS=""
              #
              # Is the length of $FILE_DESCR String longer than 28 characters?
              # Truncate string length so Dialog f_select works on an 80x24 character VGA display.
              #FILE_DESCR=${FILE_DESCR:0:28}
              #
              # Reset ERROR for while-loop to work.
              ERROR=0
              #
              while [ "$ERROR" -eq 0 ]
                    do
                       # During the While-Loop, this allows for dynamic
                       # resizing of the  Dialog file selector if the user
                       # re-sizes the X-window to see more files.
                       #
                       # Get the screen resolution or X-window size.
                       #
                       # Get rows (height).
                       YSCREEN=$(stty size | awk '{ print $1 }')
                       Y=$YSCREEN
                       #
                       # Limit Dialog box to 240x72 characters across x lines.
                       if [ $Y -gt 72 ] ; then
                          Y=72
                       fi
                       #
                       if [ $Y -ge 28  ] ; then
                          # Padding is 4, around Dialog --deselect box.
                          let Y=$Y-4
                       fi
                       #
                       # Get columns (width).
                       XSCREEN=$(stty size | awk '{ print $2 }')
                       X=$XSCREEN
                       #
                       # Limit Dialog box to 240x72 characters across x lines.
                       if [ $X -gt 240 ] ; then
                          X=240
                       fi
                       #
                       if [ $X -ge 84  ] ; then
                          # Padding is 4, around Dialog --deselect box.
                          let X=$X-4
                       fi
                       #
                       # The dialog --fselect --backtitle "Please choose $FILE_DESCR"
                       # will only display if screen/window resolution is at least 30 lines vertically.
                       # If less than 30 lines, the directory browser --dselect
                       # will still be displayed but without the --backtitle.
                       #
                       # If window size is less than 80 x 24, then Dialog f_select_dir will not work properly.
                       if [ $YSCREEN -lt 24 ] || [ $XSCREEN -lt 80 ] ; then
                          f_message $1 "OK" "Window Size too Small" "\nThis window is too small at $XSCREEN x $YSCREEN.\n\nThe minimum window size is 80 characters x 24 lines but preferably at least 120x40.\n\nPlease increase the window size now."
                       fi
                       #
                       FILE_SELECTED=$($1 --stdout --title "Use <tab>, <up/down arrows> and <spacebar> to select a $2." --backtitle "Please choose $FILE_DESCR" --ok-label "Choose $FILE_DESCR" --cancel-label "Done choosing" --fselect $DEFAULT_DIR $Y $X)
                       ERROR=$?
                       #
                       # From man dialog page.
                       # Exit status is subject to being overridden by environment variables.
                       # The default values and corresponding environment variables that can override them are:
                       #
                       # 0    if the YES or OK button is pressed (DIALOG_OK).
                       #
                       # 1    if the No or Cancel button is pressed (DIALOG_CANCEL).
                       #
                       # 2    if the Help button is pressed (DIALOG_HELP),
                       #      except as noted below about DIALOG_ITEM_HELP.
                       #
                       # 3    if the Extra button is pressed (DIALOG_EXTRA).
                       #
                       # 4    if the Help button is pressed,
                       #      and the --item-help option is set
                       #      and the DIALOG_ITEM_HELP environment variable is set to 4.
                       #
                       #      While any of the exit-codes can be overridden using
                       #      environment variables, this special case was introduced
                       #      in 2004 to simplify compatibility.
                       #
                       #      Dialog uses DIALOG_ITEM_HELP(4)  internally,  but  unless  the  environment
                       #      variable is also set, it changes that to DIALOG_HELP(2) on exit.
                       #
                       # -1   if errors occur inside dialog (DIALOG_ERROR) or dialog exits because the ESC key (DIALOG_ESC) was pressed.
                       #
                       # Verify each file selected $FILE_SELECTED and append to file TEMP_FILE2.
                       f_select_file_verify $1 "$FILE_DESCR" "$DEFAULT_DIR" "$FILE_SELECTED" $4
                       # Outputs TEMP_FILE2 which has a list of file names in a single column.
                    done
              # Process output of file selection.
              f_select_file_output $1 "$FILE_DESCR" "$DEFAULT_DIR" "$TEMP_FILE2" $4
              # Outputs ANS a string with selected file names separated by spaces.
              # (List of selected files delimited by spaces: "DIR1/FILE1 DIR2/FILE2 DIR3/FILE3...")
           ;;
           whiptail | text)
              #
              # Delete TEMP_FILE2.
              if [ -e "$TEMP_FILE2" ] ; then
                 rm $TEMP_FILE2
              fi
              #
              # Reset ERROR for while-loop to work.
              ERROR=0
              ANS=""
              #
              # Check if application "fzf" is installed.
              type fzf >/dev/null 2>&1
              ERROR=$?
              #
              # Is "fzf" installed?
              if [ $ERROR -eq 0 ] ; then
                 # Yes, "fzf" is installed.
                 #
                 # fzf EXIT STATUS
                 #       0      Normal exit
                 #       1      No match
                 #       2      Error
                 #       130    Interrupted with CTRL-C or ESC
                 #
                 f_message $1 "OK" "$FILE_DESCR" "At the next prompt, select the desired file name\nby typing the first few letters of the name and using the up-down arrows.\n\nPress [ Enter ] key to select file name.\n\nPress [ Esc ] key or [ Ctrl+C ] to EXIT or CANCEL selection."
                 #
                 # Only a single file name to select?
                 if [ "$4" = 1 ] ; then
                    # Yes, select only 1 file name.
                    #
                    # Find and select hidden and regular files.
                    # ANS=$(find "$DEFAULT_DIR" -type f | sort | fzf --pointer="=>" --prompt "Type file name and use up-down arrows. Esc key to skip. Select: ")
                    #
                    # Find and select regular files that are not hidden.
                    ANS=$(find "$DEFAULT_DIR" -not -path '*/.*' | sort | fzf --pointer="=>" --prompt "Type file name and use up-down arrows. Esc key to skip. Select: ")
                    ERROR=$?
                    #
                    if [ $ERROR -eq 0 ] ; then
                       # Verify each file selected $FILE_SELECTED and append to file TEMP_FILE2.
                       f_select_file_verify $1 "$FILE_DESCR" "$DEFAULT_DIR" $ANS $4
                       # Outputs TEMP_FILE2 which has a list of selected file names in a single column.
                    fi
                 else
                    # No, select multiple file names.
                    while [ "$ERROR" -eq 0 ]
                          do
                             # Application "fzf" limitation is you can only select sub-directories
                             # of the default directory during the While-loop.
                             # You cannot select a different parent directory from the default directory.
                             # i.e. if you select a file from "/home/user/Documents"
                             #      then you cannot select a file from "/home/user/Downloads",
                             #      but you could select a file from "/home/user/Documents/unread"
                             #
                             # Find and select hidden and regular files.
                             # ANS=$(find "$DEFAULT_DIR" -type f | sort | fzf --pointer="=>" --prompt "Type file name and use up-down arrows. Esc key to skip. Select: ")
                             #
                             # Find and select regular files that are not hidden.
                             ANS=$(find "$DEFAULT_DIR" -not -path '*/.*' -type f | sort | fzf --pointer="=>" --prompt "Type file name and use up-down arrows. Esc key to skip. Select: ")
                             ERROR=$?
                             #
                             if [ $ERROR -eq 0 ] ; then
                                # Verify each file selected $FILE_SELECTED and append to file TEMP_FILE2.
                                f_select_file_verify $1 "$FILE_DESCR" "$DEFAULT_DIR" $ANS $4
                                # Outputs TEMP_FILE2 which has a list of selected file names in a single column.
                             fi
                          done
                 fi
              else
                 # No, "fzf" is not installed.
                 #
                 # Only a single file name to select?
                 if [ "$4" = 1 ] ; then
                    # Yes, select only 1 file name.
                    f_ask_question $1 "Select a file" "Type file name with full path"
                    #
                    if [ $ERROR -eq 0 ] ; then
                       # Verify each file selected $FILE_SELECTED and append to file TEMP_FILE2.
                       f_select_file_verify $1 "$FILE_DESCR" "$DEFAULT_DIR" "$ANS" $4
                       # Outputs TEMP_FILE2 which has a list of file names in a single column.
                    fi
                 else
                    # No, select multiple file names.
                    while [ "$ERROR" -eq 0 ]
                          do
                             f_ask_question $1 "Select a file" "Type file name with full path"
                             #
                             if [ $ERROR -eq 0 ] ; then
                                # Verify each file selected $FILE_SELECTED and append to file TEMP_FILE2.
                                f_select_file_verify $1 "$FILE_DESCR" "$DEFAULT_DIR" "$ANS" $4
                                # Outputs TEMP_FILE2 which has a list of file names in a single column.
                             fi
                          done
                 fi
              fi
              #
              # Process output of file selection.
              f_select_file_output $1 "$FILE_DESCR" "$DEFAULT_DIR" "$TEMP_FILE2" $4
              # Outputs ANS a string with selected file names separated by spaces.
              # (List of selected files delimited by spaces: "DIR1/FILE1 DIR2/FILE2 DIR3/FILE3...")
           ;;
      esac
      #
}  # End of function f_select_file.
#
# +----------------------------------------+
# |      Function f_select_file_verify     |
# +----------------------------------------+
#
#     Rev: 2023-12-29
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - String File Description
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#                  !!! String cannot be longer than 28 characters !!!
#          $3 - Default directory or Default directory/file name.
#          $4 - FILE_SELECTED File selected by user entry.
#          $5 - [Optional] 1/0 1=Select only one file
#                              0 or null=Select multiple files.
#
#          THIS_DIR, THIS_FILE.
#    Uses: FILE_DESCR, DEFAULT_DIR, FILE_SELECTED, ANS, ERROR.
# Outputs: TEMP_FILE2 - Temporary file contains a list of file names.
#                              Example: cat $4
#                                       DIR1/FILE1
#                                       DIR2/FILE2
#                                       DIR3/FILE3
#          ERROR.
#
# Summary: Verify existence and choice of the user-entered file name.
#
# Dependencies: f_yn_question, f_message.
#
f_select_file_verify () {
      #
      # Initialize variables.
      FILE_DESCR=$2
      DEFAULT_DIR=$3
      FILE_SELECTED=$4
      #
      # Was any file selected?
      if [ $ERROR -eq 0 ] && [ -n $FILE_SELECTED ] ; then
         f_yn_question $1 "Y" "Confirm $FILE_DESCR name" "$FILE_DESCR name:\n$FILE_SELECTED\n\nIs the $FILE_DESCR name correct?"
         #
         # Is the selected file name correct?
         if [ "$ANS" -ne 1 ] ; then
            # Yes, $FILE_SELECTED name is correct. Note: $FILE_SELECTED includes "Directory/File Name".
            #
            # Does the file exist?
            if [ -f "$FILE_SELECTED" ] ; then
               # Yes, file $FILE_SELECTED exists.
               #
               # Add selected file to list of selected files in TEMP_FILE2
               echo $FILE_SELECTED >> $TEMP_FILE2
               #
               # Only select a single file?
               if [ "$5" = 1 ] ; then
                  # Yes, a single file has already been selected
                  # so exit loop by setting ERROR flag.
                  ERROR=1
               else
                  # No, multiple files can be selected, so continue.
                  case $1 in
                  dialog)
                     f_message $1 "NOK" "File Entered" "File name accepted. Enter next file name or press \"Done choosing\" button.\n\n$FILE_SELECTED" 2
                  ;;
                  whiptail | text)
                     f_message $1 "NOK" "File Entered" "File name accepted. Enter next file name or press \"Esc\" key to exit.\n\n$FILE_SELECTED" 2
                  ;;
                  esac
               fi
            else
               # No, $FILE_SELECTED does not exist.
               f_yn_question $1 "N" "Error $FILE_SELECTED Missing" "\n$FILE_SELECTED does not exist:\n$FILE_SELECTED\n\nDo you want to create a new directory/file?"
               #
               if [ $ANS -eq 0 ] ; then
                  # Create new sub-directory.
                  # Set NEW_DIR to newly selected base directory.
                  NEW_DIR=$(dirname $FILE_SELECTED)
                  #
                  mkdir -p $NEW_DIR
                  #
                  # Create new file.
                  touch $FILE_SELECTED
                  #
                  # Add selected file to list of selected files in TEMP_FILE2
                  echo $FILE_SELECTED >> $TEMP_FILE2
               fi
            fi
         fi
      fi
      #
}  # End of function f_select_file_verify.
#
# +----------------------------------------+
# |      Function f_select_file_output     |
# +----------------------------------------+
#
#     Rev: 2023-12-29
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - String File Description
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#                  !!! String cannot be longer than 28 characters !!!
#          $3 - Default directory or Default directory/file name.
#          $4 - Temporary file contains a list of file names.
#                              Example: cat $4
#                                       DIR1/FILE1
#                                       DIR2/FILE2
#                                       DIR3/FILE3
#          $5 - [Optional] 1/0 1=Select only one file
#                              0 or null=Select multiple files.
#
#          THIS_DIR, THIS_FILE.
#    Uses: TEMP_FILE2, TEMP_FILE3.
# Outputs: ANS (List of selected files delimited by spaces: "DIR1/FILE1 DIR2/FILE2 DIR3/FILE3...")
#          ERROR.
#
# Summary: Prompt user-entered file name.
#
# Dependencies: f_yn_question, f_message.
#
f_select_file_output () {
      #
      # Outputs: $5 has list of files delimited by spaces.
      #         (List of selected files: "DIR1/FILE1 DIR2/FILE2 DIR3/FILE3...").
      #
      # If "Cancel" button was pressed during Dialog f_select,
      # then temporary file $4 was never created.
      # $4 may be null or $4 may be $5 (if $5 has a string "1" or "0").
      # Test if $4 is an existing temporary file name.
      #
      # Was "Cancel" button pressed by user during f_select?
      if [ -f $4 ] ; then
         # No, "Cancel" button was not pressed, continue with selected file(s)
         #
         # Were multiple files selected?
         if [ "$5" != 1 ] ; then
            # Yes, multiple files are selected so display list of files
            # followed by a Go/NoGo question.
            #
            # $4 still contains the list of selected files which
            # was the result of the Dialog fselect command.
            # So don't change contents.
            #
            # Build a list of selected files followed by a Go/NoGo question.
            # Use temporary file TEMP_FILE3 for this.
            TEMP_FILE3=$4"_temp3.txt"
            #
            # Compose the text necessary to ask the question using function f_yn_question.
            cat $4 > $TEMP_FILE3
            echo >> $TEMP_FILE3
            echo "Are_all_the_file_names_correct?_Continue_to_process_files?" >> $TEMP_FILE3
            #
            # Convert text in TEMP_FILE3 to be displayable by function f_yn_question.
            # Convert text file into a single sentence string.
            # Convert the multi-lines of data in the temporary text file to a single line string.
            # This is needed because f_ask_question can take only a string as a parameter and not a file.
            #
            # Translate "\n" or the <crlf> to "|". Join all lines together delimited by "|".
            cat $TEMP_FILE3 | tr "\n" "|"  > $TEMP_FILE3"-out.txt" ; sed -i 's/|/\\n/g' $TEMP_FILE3"-out.txt"
            mv $TEMP_FILE3"-out.txt" $TEMP_FILE3
            X=$(cat $TEMP_FILE3)
            #
            # Now can ask the actual question to continue or not.
            f_yn_question $1 "Y" "Continue?" $X
            #
            # Was the answer "Y" Continue?
            if [ $ANS -eq 0 ] ; then
               # Yes, continue with processing.
               # Use as input $4 Temp File of list of file names
               # Output to ANS containing a string of file names delimited by a space.
               if [ -e $TEMP_FILE3 ] ; then
                  rm $TEMP_FILE3
               fi
               #
               # Convert single-column list of file names contained in temp file $4
               # to single string of file names delimited by space.
               while read LINE
                     do
                        echo -n $LINE" " >> $TEMP_FILE3
                     done < $4
               ANS=$(cat $TEMP_FILE3)
            else
               # Do not continue with processing, set $ANS to null.
               ANS=""
            fi
         else
            # No, only a single file allowed to be selected ($4=1).
            # Set $ANS string to include the single file name.
            ANS=$(cat $4)
         fi
      else
         # Yes, Cancel button pressed.
         ANS=""
      fi
      #
      # Reset ERROR since on exiting WHILE-loop it will always be EXIT=1.
      ERROR=0
      #
      # clear                           # Diagnostic line.
      # echo "Diagnostics display $4"   # Diagnostic line.
      # cat $4                          # Diagnostic line.
      # echo                            # Diagnostic line.
      # echo ----                       # Diagnostic line.
      # echo "Diagnostics display ANS"  # Diagnostic line.
      # echo $ANS                       # Diagnostic line.
      # read X                          # Diagnostic line.
      #
      if [ -e "$4" ] ; then
         rm $4
      fi
      #
      if [ -e "$TEMP_FILE3" ] ; then
         rm $TEMP_FILE3
      fi
      #
}  # End of function f_select_file_output.
#
# +----------------------------------------+
# |         Function f_choose_files        |
# +----------------------------------------+
#
#     Rev: 2022-02-28
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - String "[Data File Description] File(s)".
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#          $3 - Default directory.
#          $4=Function name to call.
#    Uses: None.
# Outputs: None.
#
# Summary: Select data file(s) to process one at a time using a given function.
#
# Dependencies: f_select_file.
#
f_choose_files () {
      #
      # Select file with regular address list.
      # Address data file ($FILE"_address.txt") containing text data.
      #
      f_select_file $1 "$2" $3
      #
      # Set FILE_LIST to the list of selected files of string $ANS output from f_select_files.
      FILE_LIST=$ANS
      #
      # Outputs: ANS (List of selected files: "DIR1/FILE1 DIR2/FILE2 DIR3/FILE3..."), ERROR.
      if [ -n "$FILE_LIST" ] ; then
         # Valid files selected.
         # Format:
         # FILE_TXT="<FILE1> <FILE2>...<FILEn>"
         #
         # Call function name $4 for each file $FILE.
         for FILE in $FILE_LIST
             do
                # Format: <Function-to-call> <GUI> <Description> <Selected File name>
                $4 $1 $2 $FILE
             done
      fi
      unset FILE FILE_LIST FILE_STR
      #
}  # End of function f_choose_files.
#
# +----------------------------------------+
# |         Function f_ask_question        |
# +----------------------------------------+
#
#     Rev: 2022-05-17
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - Title string.
#          $3 - Question text string or text file.
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#          $4 - [Optional] Default answer - Default answer string.
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#    Uses: None.
# Outputs: ANS=String.
#          ERROR=1 "Exit" or "Cancel" button pressed in Dialog or Whiptail.
#          ERROR=255 if <Esc> is pressed in dialog/whiptail --input box.
#
# Example:
#          Using a question string:
#          f_ask_question $GUI "Hungry Hippo" "I am hungry.\nWhat do you want to eat?" "Pizza"
#
#          Using a question with additional text in a text file: (which may include an expanation, example, etc.)
#          f_ask_question "dialog" "Hungry Hippo" hungry.txt "Pizza"
#          Where file hungry.txt may include:
#                                             We have a choice between Italian, Chinese, fast food, or pizza.
#                                             I am hungry.
#                                             What do you want to eat?"
#
# Summary: This will display a title and a question using dialog/whiptail/text.
#          It will automatically calculate the optimum size of the displayed
#          Dialog or Whiptail box depending on screen resolution, number of lines
#          of text, and length of sentences to be displayed.
#
#          It is a lengthy function, but using it allows for an easy way to display
#          a question and allow user-input answer using either Dialog, Whiptail or text.
#
#          You do not have to worry about the differences in syntax between Dialog
#          and Whiptail, handling the answer, or about calculating the box size for
#          each text message.
#
# Dependencies: f_msg_ui_str_box_size, f_yn_defaults.
#
f_ask_question () {
      #
      # Get the screen resolution or X-window size.
      # Get rows (height).
      YSCREEN=$(stty size | awk '{ print $1 }')
      # Get columns (width).
      XSCREEN=$(stty size | awk '{ print $2 }')
      #
      # Initialize variable.
      QUESTION="$3"
      #
      # Is $3 a text file?
      if [ -r "$3" ] ; then
         # Yes $3 is a text file.
         #
         # Convert text in TEMP_FILE3 to be displayable by function f_yn_question.
         # Convert text file into a single sentence string.
         # Convert the multi-lines of data in the temporary text file to a single line string.
         # This is needed because f_ask_question can take only a string as a parameter and not a file.
         #
         # Translate "\n" or the <crlf> to "|". Join all lines together delimited by "|".
         cat $TEMP_FILE | tr "\n" "|" >$TEMP_FILE"_2.txt"
         #
         # Substitute string "|" with string "\n"
         sed -i 's/|/\\n/g' $TEMP_FILE"_2.txt"
         #
         # Preserve spacing in text by substituting underscores for spaces.
         # Spaces cannot be in the string when it is passed as a parameter to function f_ask_question.
         sed -i 's/ /_/g' $TEMP_FILE"_2.txt"
         #
         # Create string QUESTION from the converted string in the temporary file.
         QUESTION=$(cat $TEMP_FILE"_2.txt")
         #
         # Delete temporary file.
         if [ -e $TEMP_FILE"_2.txt" ] ; then
            rm $TEMP_FILE"_2.txt"
         fi
      fi
      #
      case $1 in
           dialog | whiptail)
              # Calculate dialog/whiptail box dimensions $YBOX, $XBOX.
              # Calculate box dimensions for $4 Default answer string.
              f_msg_ui_str_box_size "$4"
              XBOX_MAX=$XBOX
              #
              # Calculate box dimensions for $2 Title string.
              f_msg_ui_str_box_size "$2"
              #
              if [ $XBOX -gt $XBOX_MAX ] ; then
                 XBOX_MAX=$XBOX
              fi
              #
              # Calculate box dimensions for $3 Question string.
              f_msg_ui_str_box_size "$QUESTION"
              #
              if [ $XBOX -gt $XBOX_MAX ] ; then
                 XBOX_MAX=$XBOX
              fi
              #
              XBOX=$XBOX_MAX
           ;;
      esac
      #
      case $1 in
           dialog)
              # Dialog needs about 5 more lines for the header and [OK] button.
              let Y=$YBOX+5
              # If number of lines exceeds screen/window height then set textbox height.
              if [ $Y -ge $YSCREEN ] ; then
                 Y=$YSCREEN
              fi
              #
              # Dialog needs about 10 more spaces for the right and left window frame.
              let X=$XBOX+10
              # If line length exceeds screen/window width then set textbox width.
              if [ $X -ge $XSCREEN ] ; then
                 X=$XSCREEN
              fi
              #
              # Define question string.
              # Format string, substitute spaces for underscores.
              QUESTION=$(echo $QUESTION | tr '_' ' ')
           ;;
           whiptail)
              # Whiptail does not have option "--colors" with "\Z" commands for font color bold/normal.
              # Filter out any "\Z" commands when using the same string for both Dialog and Whiptail.
              # Use command "sed" with "-e" to filter out multiple "\Z" commands.
              # Filter out "\Z[0-7]", "\Zb", \ZB", "\Zr", "\ZR", "\Zu", "\ZU", "\Zn".
              ZNO=$(echo $QUESTION | sed -e 's|\\Z0||g' -e 's|\\Z1||g' -e 's|\\Z2||g' -e 's|\\Z3||g' -e 's|\\Z4||g' -e 's|\\Z5||g' -e 's|\\Z6||g' -e 's|\\Z7||g' -e 's|\\Zb||g' -e 's|\\ZB||g' -e 's|\\Zr||g' -e 's|\\ZR||g' -e 's|\\Zu||g' -e 's|\\ZU||g' -e 's|\\Zn||g')
              #
              # Whiptail needs about 6 more lines for the header and [OK] button.
              let Y=$YBOX+6
              # If number of lines exceeds screen/window height then set textbox height.
              if [ $Y -ge $YSCREEN ] ; then
                 Y=$YSCREEN
              fi
              #
              # Whiptail needs about 6 more spaces for the right and left window frame.
              let X=$XBOX+6
              # If line length exceeds screen/window width then set textbox width.
              if [ $X -ge $XSCREEN ] ; then
                 X=$XSCREEN
              fi
              #
              # Define question string.
              # Format string, substitute spaces for underscores.
              QUESTION=$(echo $ZNO | tr '_' ' ')
           ;;
           text)
              # Does $QUESTION contain "\n"?  Does the string $3 contain multiple sentences?
              case $3 in
                   *\n*)
                      # Yes, string $QUESTION contains multiple sentences.
                      #
                      # Command-Line interface (CLI) does not have option "--colors" with "\Z" commands for font color bold/normal.
                      # Use command "sed" with "-e" to filter out multiple "\Z" commands.
                      # Filter out "\Z[0-7]", "\Zb", \ZB", "\Zr", "\ZR", "\Zu", "\ZU", "\Zn".
                      ZNO=$(echo "$QUESTION" | sed -e 's|\\Z0||g' -e 's|\\Z1||g' -e 's|\\Z2||g' -e 's|\\Z3||g' -e 's|\\Z4||g' -e 's|\\Z5||g' -e 's|\\Z6||g' -e 's|\\Z7||g' -e 's|\\Zb||g' -e 's|\\ZB||g' -e 's|\\Zr||g' -e 's|\\ZR||g' -e 's|\\Zu||g' -e 's|\\ZU||g' -e 's|\\Zn||g')
                      #
                   ;;
                   *)
                      # No, string $QUESTION contains a single sentence.
                      #
                      # Create a text file from the string.
                      ZNO="$QUESTION"
                   ;;
              esac
              #
              # Define question string.
              # Format string, substitute spaces for underscores.
              QUESTION=$(echo $ZNO | tr '_' ' ')
           ;;
      esac
      #
      # Initialize variables.
      # Do not substitute spaces for underscores for DEFAULT since it may be a directory or file.
      DEFAULT=$4
      #
      # Define Title string.
      # Format string, substitute spaces for underscores.
      TITLE=$(echo $2 | tr '_' ' ')
      ERROR=0
      #
      case $1 in
           dialog)
              # Ask question.
              $1 --title "$TITLE" --cancel-label "Exit" --inputbox "$QUESTION" $Y $X "$DEFAULT" 2>$TEMP_FILE
              ERROR=$?
              ANS=$(cat $TEMP_FILE)
           ;;
           whiptail)
              # Ask question.
              $1 --title "$TITLE" --cancel-button "Exit" --inputbox "$QUESTION" $Y $X "$DEFAULT" 2>$TEMP_FILE
              ERROR=$?
              ANS=$(cat $TEMP_FILE)
           ;;
           text)
              clear  # Blank screen.
              #
              # Ask question.
              echo "$TITLE"
              echo
              echo -n -e "$QUESTION ($DEFAULT):"
              read ANS
              if [ -z $ANS ] ; then
                 ANS="$DEFAULT"
              fi
           ;;
      esac
      #
}  # End of function f_ask_question
#
# +----------------------------------------+
# |          Function f_yn_question        |
# +----------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "Y" or "N" - the default answer.
#          $3 - Title string (may be null).
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#          $4 - Question text string.
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#    Uses: None.
# Outputs: ANS=0 is "Yes".
#          ANS=1 is "No".
#          ANS=255 if <Esc> is pressed in dialog/whiptail --yesno box.
# Example: f_yn_question $GUI "Y" "Title Goes Here" "I am hungry.\nAre you hungry?"
#          f_yn_question "dialog" "Y" "Title Goes Here" hungry.txt
#
# Summary: This will display a title and a question using dialog/whiptail/text.
#          It will automatically calculate the optimum size of the displayed
#          Dialog or Whiptail box depending on screen resolution, number of lines
#          of text, and length of sentences to be displayed.
#
#          It is a lengthy function, but using it allows for an easy way to display
#          a yes/no question using either Dialog, Whiptail or text.
#
#          You do not have to worry about the differences in syntax between Dialog
#          and Whiptail, handling the answer, or about calculating the box size for
#          each text message.
#
# Dependencies: f_msg_ui_str_box_size, f_yn_defaults.
#
f_yn_question () {
      #
      # Ask Yes/No question.
      #
      # Set Temporary file name.
      #THIS_FILE="example_library.lib"
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
      #
      case $1 in
           dialog | whiptail)
              # Get the screen resolution or X-window size.
              # Get rows (height).
              YSCREEN=$(stty size | awk '{ print $1 }')
              # Get columns (width).
              XSCREEN=$(stty size | awk '{ print $2 }')
              #
              # Calculate dialog/whiptail box dimensions $YBOX, $XBOX.
              f_msg_ui_str_box_size "$4"
           ;;
      esac
      #
      case $1 in
           dialog)
              # Dialog needs about 5 more lines for the header and [OK] button.
              let Y=$YBOX+5
              # If number of lines exceeds screen/window height then set textbox height.
              if [ $Y -ge $YSCREEN ] ; then
                 Y=$YSCREEN
              fi
              #
              # Dialog needs about 10 more spaces for the right and left window frame.
              let X=$XBOX+10
              # If line length exceeds screen/window width then set textbox width.
              if [ $X -ge $XSCREEN ] ; then
                 X=$XSCREEN
              fi
           ;;
           whiptail)
              # Whiptail only has options --textbox or--msgbox (not --infobox).
              # Whiptail does not have option "--colors" with "\Z" commands for font color bold/normal.
              # Filter out any "\Z" commands when using the same string for both Dialog and Whiptail.
              # Use command "sed" with "-e" to filter out multiple "\Z" commands.
              # Filter out "\Z[0-7]", "\Zb", \ZB", "\Zr", "\ZR", "\Zu", "\ZU", "\Zn".
              ZNO=$(echo $4 | sed -e 's|\\Z0||g' -e 's|\\Z1||g' -e 's|\\Z2||g' -e 's|\\Z3||g' -e 's|\\Z4||g' -e 's|\\Z5||g' -e 's|\\Z6||g' -e 's|\\Z7||g' -e 's|\\Zb||g' -e 's|\\ZB||g' -e 's|\\Zr||g' -e 's|\\ZR||g' -e 's|\\Zu||g' -e 's|\\ZU||g' -e 's|\\Zn||g')
              #
              # Whiptail needs about 6 more lines for the header and [OK] button.
              let Y=$YBOX+6
              # If number of lines exceeds screen/window height then set textbox height.
              if [ $Y -ge $YSCREEN ] ; then
                 Y=$YSCREEN
              fi
              #
              # Whiptail needs about 6 more spaces for the right and left window frame.
              let X=$XBOX+6
              # If line length exceeds screen/window width then set textbox width.
              if [ $X -ge $XSCREEN ] ; then
                 X=$XSCREEN
              fi
           ;;
      esac
      #
      case $1 in
           dialog | whiptail)
              # Default answer.
              f_yn_defaults $1 $2 "$3" "$4" $Y $X
           ;;
           text)
              clear  # Blank screen.
              #
              # Does $4 contain "\n"?  Does the string $4 contain multiple sentences?
              case $4 in
                   *\n*)
                      # Yes, string $4 contains multiple sentences.
                      #
                      # Command-Line interface (CLI) does not have option "--colors" with "\Z" commands for font color bold/normal.
                      # Use command "sed" with "-e" to filter out multiple "\Z" commands.
                      # Filter out "\Z[0-7]", "\Zb", \ZB", "\Zr", "\ZR", "\Zu", "\ZU", "\Zn".
                      ZNO=$(echo $4 | sed -e 's|\\Z0||g' -e 's|\\Z1||g' -e 's|\\Z2||g' -e 's|\\Z3||g' -e 's|\\Z4||g' -e 's|\\Z5||g' -e 's|\\Z6||g' -e 's|\\Z7||g' -e 's|\\Zb||g' -e 's|\\ZB||g' -e 's|\\Zr||g' -e 's|\\ZR||g' -e 's|\\Zu||g' -e 's|\\ZU||g' -e 's|\\Zn||g')
                      XSTR="$ZNO"
                      #
                   ;;
                   *)
                      # No, string $4 contains a single sentence.
                      #
                      # Create a text file from the string.
                      XSTR="$4"
                   ;;
              esac
              #
              f_yn_defaults $1 $2 "$3" "$XSTR"
           ;;
      esac
      #
}  # End of function f_yn_question
#
# +------------------------------+
# |    Function f_yn_defaults    |
# +------------------------------+
#
#     Rev: 2022-04-01
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "Y" or "N" - the default answer.
#          $3 - Title.
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#          $4 - Text string or text file.
#          $5 - Box Height in characters.
#          $6 - Box Width  in characters.
#    Uses: None.
# Outputs: ANS=0 is "Yes".
#          ANS=1 is "No".
#
# Example:
#         whiptail --yesno text height width
#                  --defaultno
#                  --yes-button text
#                  --no-button text
#                  --backtitle backtitle
#                  --title title
#
#         dialog --yesno text height width
#                --defaultno
#                --yes-label string
#                --default-button string
#                --backtitle backtitle
#                --title title
#
# Summary: Display default answer to a Yes/No question.
#
# Dependencies: None.
#
f_yn_defaults () {
      #
      # Format string, substitute spaces for underscores.
      TITLE_STR=$(echo $3 | tr '_' ' ')
      #
      # Format string, substitute spaces for underscores.
      TEXT_STR=$(echo $4 | tr '_' ' ')
      #
      case $1 in
           dialog | whiptail)
              case $2 in
                   [Yy] | [Yy][Ee][Ss])
                      # "Yes" is the default answer.
                      $1 --title "$TITLE_STR" --yesno "$TEXT_STR" $5 $6
                      ANS=$?
                   ;;
                   [Nn] | [Nn][Oo])
                      # "No" is the default answer.
                      $1 --title "$TITLE_STR" --defaultno --yesno "$TEXT_STR" $5 $6
                      ANS=$?
                   ;;
              esac
           #
           ;;
           text)
              case $2 in
                   [Yy] | [Yy][Ee][Ss])
                      # "Yes" is the default answer.
                      echo -e -n "$TEXT_STR (Y/n) "; read ANS
                      #
                      case $ANS in
                           [Nn] | [Nn][Oo])
                              ANS=1  # No.
                           ;;
                           *)
                              ANS=0  # Yes (Default).
                           ;;
                      esac
                   ;;
                   [Nn] | [Nn][Oo])
                      # "No" is the default answer.
                      echo -e -n "$TEXT_STR (y/N) "; read ANS
                      case $ANS in
                           [Yy] | [Yy][Ee] | [Yy][Ee][Ss])
                              ANS=0  # Yes.
                           ;;
                           *)
                              ANS=1  # No (Default).
                           ;;
                      esac
                   ;;
              esac
           ;;
      esac
      #
}  # End of function f_yn_defaults
#
# +------------------------------+
# |       Function f_message     |
# +------------------------------+
#
#     Rev: 2022-09-13
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "OK"  [OK] button at end of text.
#               "NOK" No [OK] button or "Press Enter key to continue"
#               at end of text but pause n seconds
#               to allow reader to read text by using sleep n command.
#               "NOK" DOES NOT WORK FOR WHIPTAIL. Earlier versions of Whiptail do not have an --infobox option to use for "NOK".
#          $3 - Title.
#                  (String must either begin and end with double-quotes
#                  Underscores in text string are not converted to spaces).
#          $4 - Text string or text file.
#               !!!WARNING: ANY TEXT FILE MUST BE A TEMPORARY FILE AND WILL BE DELETED!!!
#                  (String must either begin and end with double-quotes
#                  Underscores in text string are not converted to spaces).
#          $5 - (Optional for functions f_msg_ui/txt_str_nok) Pause for $5 seconds to allow text to be read.
#               Default is pause for 3 seconds.
#          $6 - (Optional) Text string to substitute for the "OK" label on the "OK" button.
#          $7 - (Optional) Text string to substitute for the "Cancel" label on the "Cancel" button.
#    Uses: None.
# Outputs: ERROR.
#   Usage: 1. f_message $GUI "OK" "Test of String in quotes" "This is a test of \Z6cyan software BASH script.\n\ZnI hope it works!"
#
#          2. In this example, the quotation marks around the "$STRING" variable name are required.
#             STRING=$(echo "\"Roses are \Z1\ZbRED\Zn, Violets are \Z4BLUE\Zn, what say you?\"")
#             f_message $GUI "OK" "Test of String in a variable" "$STRING" <---!!Note required quotation marks around variable name!!
#
#          3. echo "Line 1 of text file" >$TEMP_FILE
#             echo "Line 2 of text file" >>$TEMP_FILE
#             echo "Line 3 of text file" >>$TEMP_FILE
#             f_message $GUI "OK" "Test of Text file" $TEMP_FILE
#
# Debug hint: If the box has the minimum size regardless of length or width of text,
#             the variable $TEMP_FILE may have been unset (i.e. unset TEMP_FILE).
#
#             >>> If the $TEMP_FILE is undefined,   <<<
#             >>> you will have a minimum box size. <<<
#
#             >>> TEMP_FILE must be defined even if $4 is a string. <<<
#
# Summary: This will display a title and some text using dialog/whiptail/text.
#          It will automatically calculate the optimum size of the displayed
#          Dialog or Whiptail box depending on screen resolution, number of lines
#          of text, and length of sentences to be displayed.
#
#          It is a lengthy function, but using it allows for an easy way to display
#          some text (in a string or text file) using either Dialog, Whiptail or text.
#
#          You do not have to worry about the differences in syntax between Dialog
#          and Whiptail or about calculating the box size for each text message.
#
# Dependencies: f_msg_color, f_msg_txt_file_nok, f_msg_txt_file_ok, f_msg_txt_str_nok,
#          f_msg_txt_str_ok, f_msg_ui_file_box_size, f_msg_ui_file_nok, f_msg_ui_file_ok,
#          f_msg_ui_str_box_size, f_msg_ui_str_nok, f_msg_ui_str_ok.
#
f_message () {
      #
      case $1 in
           "dialog" | "whiptail")
              # Dialog boxes "--msgbox" "--infobox" can use option --colors with "\Z" commands for font color bold/normal.
              # Dialog box "--textbox" and Whiptail cannot use option --colors with "\Z" commands for font color bold/normal.
              #
              # If text strings have Dialog "\Z" commands for font color bold/normal,
              # they must be used AFTER \n (line break) commands.
              # Example: "This is a test.\n\Z1\ZbThis is in bold-red letters.\n\ZnThis is in normal font."
              #
              # Get the screen resolution or X-window size.
              # Get rows (height).
              YSCREEN=$(stty size | awk '{ print $1 }')
              # Get columns (width).
              XSCREEN=$(stty size | awk '{ print $2 }')
              #
              # Is $4 a text file?
              if [ -e "$4" ] ; then
                 # Yes, $4 is a text file.
                 # If $4 is a text file, then calculate number of lines and length
                 # of sentences to calculate height and width of Dialog box.
                 # Calculate dialog/whiptail box dimensions $YBOX, $XBOX.
                 f_msg_ui_file_box_size "$4"
                 #
                 # Calculate length of $3 title string length.
                 XTITLE_LEN=$(echo "$3" | wc -c)
                 #
                 # Is the Title string length longer than the message line length?
                 if [ $XTITLE_LEN -gt $XBOX ] ; then
                    # Yes, increase $XBOX to greater integer or longer box width.
                    XBOX=$XTITLE_LEN
                 fi
                 #
                 if [ "$2" = "OK" ] ; then
                    # Display contents of text file with an [OK] button.
                    f_msg_ui_file_ok $1 $2 "$3" "$4" $YBOX $XBOX "$6" "$7"
                 else
                    # Display contents of text file with a pause for n seconds.
                    f_msg_ui_file_nok $1 $2 "$3" "$4" $YBOX $XBOX "$5"
                 fi
                 #
                 # Remove temporary text file.
                 rm $4
                 #
              else
                 # No, $4 is a text string.
                 # If $4 is a text string, then does it contain just one
                 # sentence or multiple sentences delimited by "\n"?
                 # Calculate the length of the longest of sentence.
                 # Calculate dialog/whiptail box dimensions $YBOX, $XBOX.
                 f_msg_ui_str_box_size "$4"
                 #
                 # Calculate length of $3 title string length.
                 XTITLE_LEN=$(echo "$3" | wc -c)
                 #
                 # Is the Title string length longer than the message line length?
                 if [ $XTITLE_LEN -gt $XBOX ] ; then
                    # Yes, increase $XBOX to greater integer or longer box width.
                    XBOX=$XTITLE_LEN
                 fi
                 #
                 if [ "$2" = "OK" ] ; then
                    # Display contents of text string with an [OK] button.
                    f_msg_ui_str_ok $1 $2 "$3" "$4" $YBOX $XBOX "$6" "$7"
                 else
                    # Display contents of text string with a pause for n seconds.
                    f_msg_ui_str_nok $1 $2 "$3" "$4" $YBOX $XBOX "$5"
                 fi
              fi
              ;;
           *)
              #
              # Text only.
              # Is $4 a text string or a text file?
              #
              # Change font color according to Dialog "\Z" commands.
              # Replace font color "\Z" commands with "tput" commands.
              # Output result to string $ZNO.
              f_msg_color "$4"
              #
              if [ -r "$4" ] ; then
                 # If $4 is a text file.
                 #
                 if [ "$2" = "OK" ] ; then
                    # Display contents of text file using command "less" <q> to quit.
                    f_msg_txt_file_ok $1 $2 "$3" "$4"
                 else
                    f_msg_txt_file_nok $1 $2 "$3" "$4" "$5"
                    # Display contents of text file using command "cat" then pause for n seconds.
                 fi
                 #
                 # Remove temporary text file.
                 rm $4
                 #
              else
                 # If $4 is a text string.
                 #
                 if [ "$2" = "OK" ] ; then
                    # Display contents of text string using command "echo -e" then
                    # use f_press_enter_key_to_continue.
                    f_msg_txt_str_ok $1 $2 "$3" "$ZNO"
                 else
                    # Display contents of text string using command "echo -e" then pause for n seconds.
                    f_msg_txt_str_nok $1 $2 "$3" "$ZNO" "$5"
                 fi
              fi
              #
              # Restore default font color.
              echo -n $(tput sgr0)
              #
           ;;
      esac
      #
}  # End of function f_message.
#
# +-------------------------------+
# |      Function f_msg_color     |
# +-------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - Text string or text file.
#    Uses: None.
# Outputs: ZNO.
#
# Summary: Used by f_message. For text UI only.
#          Change text colors according to \Z commands in the text string or file.
#
# Dependencies: None.
#
f_msg_color () {
      #
      # 1. Does the text string or file have embedded Dialog "\Z" commands?
      # 2. If so, what color?
      # 3. Use corresponding "tput" command to set same color for the text.
      # 4. Remove or filter out embedded dialog "\Z" commands.
      # 5. Display (colored) text on screen.
      # 6. Reset text color when done.
      #
      # man dialog --colors
      # Interpret embedded "\Z" sequences in the Dialog text by the following
      # character, which tells Dialog to set colors or video attributes:
      # *0 through 7 are the ANSI color numbers used in curses: black, red, green,
      #  yellow, blue, magenta, cyan and white respectively.
      # *Bold is set by 'b', reset by 'B'.
      # *Reverse is set by 'r', reset by 'R'.
      # *Underline is set by 'u', reset by 'U'.
      # *The settings are cumulative, e.g., "\Zb\Z1" makes the following text bold
      #  (perhaps bright) red.
      # *Restore normal settings with "\Zn".
      #
      # BASH commands to change the color of characters in a terminal.
      # bold    "$(tput bold)"
      # black   "$(tput setaf 0)"
      # red     "$(tput setaf 1)"
      # green   "$(tput setaf 2)"
      # yellow  "$(tput setaf 3)"
      # blue    "$(tput setaf 4)"
      # magenta "$(tput setaf 5)"
      # cyan    "$(tput setaf 6)"
      # white   "$(tput setaf 7)"
      # reset   "$(tput sgr0)"
      #
      # Change font color according to Dialog "\Z" commands.
      # Then delete the Dialog "\Z" commands from the text string/file.
      #
      if [ -r "$1" ] ; then
         # If $1 is a text file.
         for COLOR in 0 1 2 3 4 5 6 7 8 9
             do
                # Search the text file for a Dialog "\Z" command.
                ZCMD=$(grep --max-count=1 \\Z$COLOR "$1")
                #
                # Change font color according to Dialog "\Z" command.
                if [ -n "$ZCMD" ] ; then
                   # Delete Dialog "\Z" commands.
                   # Use command "sed" with "-e" to filter out multiple "\Z" commands.
                   # Filter out "\Z[0-7]", "\Zb", \ZB", "\Zr", "\ZR", "\Zu", "\ZU", "\Zn".
                   sed -i -e 's|\\Z0||g' -e 's|\\Z1||g' -e 's|\\Z2||g' -e 's|\\Z3||g' -e 's|\\Z4||g' -e 's|\\Z5||g' -e 's|\\Z6||g' -e 's|\\Z7||g' -e 's|\\Zb||g' -e 's|\\ZB||g' -e 's|\\Zr||g' -e 's|\\ZR||g' -e 's|\\Zu||g' -e 's|\\ZU||g' -e 's|\\Zn||g' $1
                   # Change font color using "tput" and "setaf" commands.
                   echo -n $(tput setaf $COLOR)
                fi
             done
      else
         # If $1 is a text string.
         for COLOR in 0 1 2 3 4 5 6 7 8 9
             do
                case "$1" in
                     *\Z0* | *\Z1* | *\Z2* | *\Z3* | *\Z4* | *\Z5* | *\Z6* | *\Z7* | *\Z8* | *\Z9*)
                        # Change font color using "tput" and "setaf" commands.
                        echo -n $(tput setaf $COLOR)
                        #
                        # Delete Dialog "\Z" commands.
                        # Use command "sed" with "-e" to filter out multiple "\Z" commands.
                        # Filter out "\Z[0-7]", "\Zb", \ZB", "\Zr", "\ZR", "\Zu", "\ZU", "\Zn".
                        ZNO=$(echo $1 | sed -e 's|\\Z0||g' -e 's|\\Z1||g' -e 's|\\Z2||g' -e 's|\\Z3||g' -e 's|\\Z4||g' -e 's|\\Z5||g' -e 's|\\Z6||g' -e 's|\\Z7||g' -e 's|\\Zb||g' -e 's|\\ZB||g' -e 's|\\Zr||g' -e 's|\\ZR||g' -e 's|\\Zu||g' -e 's|\\ZU||g' -e 's|\\Zn||g')
                     ;;
                     *)
                        ZNO=$1
                esac
             done
         #
      fi
}  # End of function f_msg_color.
#
# +---------------------------------+
# | Function f_msg_ui_file_box_size |
# +---------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - Text file.
#    Uses: None.
# Outputs: XBOX, YBOX.
#
# Summary: Used by f_message. For Dialog or Whiptail UI only.
#          Determine minimum window dimensions in characters and number of lines.
#
# Dependencies: wc.
#
f_msg_ui_file_box_size () {
      #
      # If $1 is a text file.
      # Calculate dialog/whiptail box dimensions $XBOX, $YBOX.
      #
      # If text file, calculate number of lines and length of sentences.
      # to calculate height and width of Dialog box.
      #
      # Calculate longest line length in TEMP_FILE to find maximum menu width for Dialog or Whiptail.
      # The "Word Count" wc command output will not include the TEMP_FILE name
      # if you redirect "<$TEMP_FILE" into wc.
      XBOX=$(wc --max-line-length <$1)
      #
      # Calculate number of lines or Menu Choices to find maximum menu lines for Dialog or Whiptail.
      YBOX=$(wc --lines <$1)
      #
}  # End of function f_msg_ui_file_box_size.
#
# +------------------------------+
# |   Function f_msg_ui_file_ok  |
# +------------------------------+
#
#     Rev: 2022-06-05
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "OK"  [OK] button at end of text.
#               "NOK" No [OK] button or "Press Enter key to continue"
#               at end of text but pause n seconds
#               to allow reader to read text by using sleep n command.
#          $3 - Title.
#          $4 - Text file.
#          $5 - Box Height in characters.
#          $6 - Box Width  in characters.
#          $7 - (Optional) Text string to substitute for the "OK" label on the "OK" button.
#          $8 - (Optional) Text string to substitute for the "Cancel" label on the "Cancel" button.
#
#    Uses: None.
# Outputs: ERROR.
#
# Summary: Used by f_message. For Dialog or Whiptail UI only.
#          Display contents of a text file using a Dialog or Whiptail textbox with an "OK" button.
#
# Dependencies: None.
#
f_msg_ui_file_ok () {
      #
      # $4 is a text file.
      # If $2 is "OK" then use a Dialog/Whiptail textbox.
      #
      # Is there a label substitute for the "Exit" label?
      if [ -n "$7" ] ; then
         OK_LABEL="$7"
      else
         OK_LABEL="OK"
      fi
      #
      # Get the screen resolution or X-window size.
      # Get rows (height).
      YSCREEN=$(stty size | awk '{ print $1 }')
      # Get columns (width).
      XSCREEN=$(stty size | awk '{ print $2 }')
      #
      case $1 in
           dialog)
              # Dialog needs about 6 more lines for the header and [OK] button.
              let Y=$5+6
              # If number of lines exceeds screen/window height then set textbox height.
              if [ $Y -ge $YSCREEN ] ; then
                 Y=$YSCREEN
              fi
              #
              # Dialog needs about 10 more spaces for the right and left window frame.
              let X=$6+10
              # If line length exceeds screen/window width then set textbox width.
              if [ $X -ge $XSCREEN ] ; then
                 X=$XSCREEN
              fi
              #
              # Dialog box "--textbox" and Whiptail cannot use "\Z" commands.
              # No --colors option for Dialog --textbox.
              dialog --exit-label "$OK_LABEL" --title "$3" --textbox "$4" $Y $X
           ;;
           whiptail)
              # Whiptail needs about 7 more lines for the header and [OK] button.
              let Y=$5+7
              # If number of lines exceeds screen/window height then set textbox height.
              if [ $Y -ge $YSCREEN ] ; then
                 Y=$YSCREEN
              fi
              #
              # Whiptail needs about 5 more spaces for the right and left window frame.
              let X=$6+5
              # If line length exceeds screen/window width then set textbox width.
              if [ $X -ge $XSCREEN ] ; then
                 X=$XSCREEN
              fi
              #
              whiptail --scrolltext --ok-button "$OK_LABEL" --title "$3" --textbox "$4" $Y $X
           ;;
      esac
      #
}  # End of function f_msg_ui_file_ok
#
# +------------------------------+
# |  Function f_msg_ui_file_nok  |
# +------------------------------+
#
#     Rev: 2022-06-05
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "OK"  [OK] button at end of text.
#               "NOK" No [OK] button or "Press Enter key to continue"
#               at end of text but pause n seconds
#               "NOK" DOES NOT WORK FOR WHIPTAIL. Earlier versions of Whiptail do not have an --infobox option to use for "NOK".
#               to allow reader to read text by using sleep n command.
#          $3 - Title.
#          $4 - Text string or text file.
#          $5 - Box Height in characters.
#          $6 - Box Width  in characters.
#          $7 - Pause for $7 seconds to allow text to be read.
#    Uses: None.
# Outputs: ERROR.
#
# Summary: Used by f_message. For Dialog or Whiptail UI only.
#          Display contents of a text file using a Dialog or Whiptail textbox without an "OK" button.
#
# Dependencies: None.
#
f_msg_ui_file_nok () {
      #
      # $4 is a text file.
      # If $2 is "NOK" then use a Dialog infobox or Whiptail textbox.
      #
      # Get the screen resolution or X-window size.
      # Get rows (height).
      YSCREEN=$(stty size | awk '{ print $1 }')
      # Get columns (width).
      XSCREEN=$(stty size | awk '{ print $2 }')
      #
      case $1 in
           dialog)
              # Dialog needs about 6 more lines for the header and [OK] button.
              let Y=$5+6
              # If number of lines exceeds screen/window height then set textbox height.
              if [ $Y -ge $YSCREEN ] ; then
                 Y=$YSCREEN
              fi
              #
              # Dialog needs about 10 more spaces for the right and left window frame.
              let X=$6+10
              # If line length exceeds screen/window width then set textbox width.
              if [ $X -ge $XSCREEN ] ; then
                 X=$XSCREEN
              fi
              #
              # Dialog boxes "--msgbox" "--infobox" can use option --colors with "\Z" commands for font color bold/normal.
              # Use --infobox to display text without an "OK" button.
              # Convert text file to a string with "\n" (line feeds)
              # because Dialog or Whiptail infobox needs a string for input.
              STRING=$(sed 's/$/\\n/g' $4)
              STRING=$(echo $STRING | sed 's/\\n /\\n/g')
              dialog --colors --title "$3" --infobox "$STRING" $Y $X
              #
              # Is the pause for n seconds specified?
              if [ -z $7 ] ; then
                 # No, set a default n seconds to pause.
                 sleep 3
              else
                 # Yes, use n seconds to pause.
                 sleep "$7"
              fi
           ;;
           whiptail)
              # Whiptail only has options --textbox or--msgbox (not --infobox in earlier versions).
              # Whiptail does not have option "--colors" with "\Z" commands for font color bold/normal.
              #
              # Whiptail needs about 7 more lines for the header and [OK] button.
              let Y=$5+7
              # If number of lines exceeds screen/window height then set textbox height.
              if [ $Y -ge $YSCREEN ] ; then
                 Y=$YSCREEN
              fi
              #
              # Whiptail needs about 5 more spaces for the right and left window frame.
              let X=$6+5
              # If line length exceeds screen/window width then set textbox width.
              if [ $X -ge $XSCREEN ] ; then
                 X=$XSCREEN
              fi
              # Whiptail only has options --textbox or--msgbox (not --infobox in earlier versions).
              # Therefore for earlier versions cannot use Whiptail --infobox for no "OK" button but must use --textbox instead.
              # Uncomment line below for older versions of Whiptail lacking --infobox option.
              whiptail --title "$3" --textbox "$4" $Y $X
              #
              # "NOK" DOES NOT WORK FOR WHIPTAIL. Earlier versions of Whiptail do not have an --infobox option to use for "NOK".
              # Later versions of Whiptail have --infobox option.
              #
              # Use --infobox to display text without an "OK" button.
              # Convert text file to a string with "\n" (line feeds)
              # because Dialog or Whiptail infobox needs a string for input.
              #STRING=$(sed 's/$/\\n/g' $4)
              #STRING=$(echo $STRING | sed 's/\\n /\\n/g')
              #whiptail --title "$3" --infobox "$STRING" $Y $X
              #
              # Is the pause for n seconds specified?
              #if [ -z $7 ] ; then
              # No, set a default n seconds to pause.
              #   sleep 3
              #else
              #   sleep "$7"
              #fi
           ;;
      esac
      #
}  # End of function f_msg_ui_file_nok
#
# +--------------------------------+
# | Function f_msg_ui_str_box_size |
# +--------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - Text string.
#    Uses: None.
# Outputs: XBOX, YBOX, ZNO (string stripped of Dialog "\Z" commands).
#
# Summary: Used by f_message. For Dialog or Whiptail UI only.
#          Determine minimum window dimensions in characters and number of lines.
#          If the text to be displayed is a string with multiple "\n" line breaks,
#          The string will be converted to a text file with multiple lines
#          and then wc will count the number of lines and longest line length
#          to get the minimum window dimensions.
#
# Dependencies: wc.
#
f_msg_ui_str_box_size () {
      #
      # Calculate dialog/whiptail box dimensions $X, $Y.
      #
      # Does $1 string contain "\n"?  Does the string $4 contain multiple sentences?
      #
      # Debug hint: If the box has the minimum size regardless of length or width of text,
      #             the variable $TEMP_FILE may have been unset (i.e. unset TEMP_FILE).
      #
      #             >>> If the $TEMP_FILE is undefined,   <<<
      #             >>> you will have a minimum box size. <<<
      #
      #             >>> TEMP_FILE must be defined even if $1 is a string. <<<
      #
      case $1 in
           *\n*)
              # Yes, string $1 contains multiple sentences.
              #
              # Use command "sed" with "-e" to filter out multiple "\Z" commands.
              # Filter out "\Z[0-7]", "\Zb", \ZB", "\Zr", "\ZR", "\Zu", "\ZU", "\Zn".
              ZNO=$(echo $1 | sed -e 's|\\Z0||g' -e 's|\\Z1||g' -e 's|\\Z2||g' -e 's|\\Z3||g' -e 's|\\Z4||g' -e 's|\\Z5||g' -e 's|\\Z6||g' -e 's|\\Z7||g' -e 's|\\Zb||g' -e 's|\\ZB||g' -e 's|\\Zr||g' -e 's|\\ZR||g' -e 's|\\Zu||g' -e 's|\\ZU||g' -e 's|\\Zn||g')
              #
              # Calculate the length of the longest sentence with the $4 string.
              # How many sentences?
              # Replace "\n" with "%" and then use awk to count how many sentences.
              # Save number of sentences.
              # Use wc --lines on TEMP_FILE instead of sed-awk below.
              #YBOX=$(echo $ZNO | sed 's|\\n|%|g'| awk -F '%' '{print NF}')
              #
              # Output string without Dialog "\Z" commands into file $TEMP_FILE for wc processing.
              # The echo -e option replaces "\n" with actual <CR><LF> for wc to calculate actual longest line length.
              echo -e "$ZNO" > $TEMP_FILE
              #
              # More complex method to calculate longest sentence length,
              # without depending on "wc" but using "awk" instead.
              # Extract each sentence
              # Replace "\n" with "%" and then use awk to print current sentence.
              # This is the long way... echo $ZNO | sed 's|\\n|%|g'| awk -F "%" '{ for (i=1; i<NF+1; i=i+1) print $i }' >$TEMP_FILE
              #
              # Simpler method to calculate longest sentence length,
              # using "wc".
              # Calculate longest line length in TEMP_FILE
              # to find maximum menu width for Dialog or Whiptail.
              # The "Word Count" wc command output will not include
              # the TEMP_FILE name if you redirect "<$TEMP_FILE" into wc.
              XBOX=$(wc --max-line-length < $TEMP_FILE)
              YBOX=$(wc --lines < $TEMP_FILE)
           ;;
           *)
              # Use command "sed" with "-e" to filter out multiple "\Z" commands.
              # Filter out "\Z[0-7]", "\Zb", \ZB", "\Zr", "\ZR", "\Zu", "\ZU", "\Zn".
              ZNO=$(echo $1 | sed -e 's|\\Z0||g' -e 's|\\Z1||g' -e 's|\\Z2||g' -e 's|\\Z3||g' -e 's|\\Z4||g' -e 's|\\Z5||g' -e 's|\\Z6||g' -e 's|\\Z7||g' -e 's|\\Zb||g' -e 's|\\ZB||g' -e 's|\\Zr||g' -e 's|\\ZR||g' -e 's|\\Zu||g' -e 's|\\ZU||g' -e 's|\\Zn||g')
              #
              # No, line length is $4 string length.
              XBOX=$(echo -n "$ZNO" | wc -c)
              # Only one sentence and one line in the $1 string.
              YBOX=1
           ;;
      esac
      #
}  # End of function f_msg_ui_str_box_size
#
# +------------------------------+
# |   Function f_msg_ui_str_ok   |
# +------------------------------+
#
#     Rev: 2022-06-05
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "OK"  [OK] button at end of text.
#               "NOK" No [OK] button or "Press Enter key to continue"
#               at end of text but pause n seconds
#               to allow reader to read text by using sleep n command.
#          $3 - Title.
#          $4 - Text string or text file.
#          $5 - Box Height in characters.
#          $6 - Box Width  in characters.
#          $7 - (Optional) Text string to substitute for the "OK" label on the "OK" button.
#          $8 - (Optional) Text string to substitute for the "Cancel" label on the "Cancel" button.
#    Uses: None.
# Outputs: ERROR.
#
# Summary: Used by f_message. For Dialog or Whiptail UI only.
#          Display contents of a text string using a Dialog or Whiptail msgbox with an "OK" button.
#
# Dependencies: None.
#
f_msg_ui_str_ok () {
      #
      # $4 is a text string.
      # If $2 is "OK" then use a Dialog/Whiptail msgbox.
      #
      # Calculate line length of $4 if it contains "\n" <new line> markers.
      # Find length of all sentences delimited by "\n"
      #
      # Is there a label substitute for the "OK" label?
      if [ -n "$7" ] ; then
         OK_LABEL="$7"
      else
         OK_LABEL="OK"
      fi
      #
      # Get the screen resolution or X-window size.
      # Get rows (height).
      YSCREEN=$(stty size | awk '{ print $1 }')
      # Get columns (width).
      XSCREEN=$(stty size | awk '{ print $2 }')
      #
      case $1 in
           dialog)
              # Dialog needs about 6 more lines for the header and [OK] button.
              let Y=$5+6
              # If number of lines exceeds screen/window height then set textbox height.
              if [ $Y -ge $YSCREEN ] ; then
                 Y=$YSCREEN
              fi
              #
              # Dialog needs about 10 more spaces for the right and left window frame.
              let X=$6+10
              # If line length exceeds screen/window width then set textbox width.
              if [ $X -ge $XSCREEN ] ; then
                 X=$XSCREEN
              fi
              #
              # Dialog boxes "--msgbox" "--infobox" can use option --colors with "\Z" commands for font color bold/normal.
              dialog --colors --title "$3" --ok-label "$OK_LABEL" --msgbox "$4" $Y $X
           ;;
           whiptail)
              # Whiptail only has options --textbox or--msgbox (not --infobox in earlier versions).
              # Whiptail does not have option "--colors" with "\Z" commands for font color bold/normal.
              #
              # Whiptail needs about 6 more lines for the header and [OK] button.
              let Y=$5+6
              # If number of lines exceeds screen/window height then set textbox height.
              if [ $Y -ge $YSCREEN ] ; then
                 Y=$YSCREEN
              fi
              #
              # Whiptail needs about 5 more spaces for the right and left window frame.
              let X=$6+5
              # If line length exceeds screen/window width then set textbox width.
              if [ $X -ge $XSCREEN ] ; then
                 X=$XSCREEN
              fi
              #
              # Is there a label substitute for the "OK" label?
              if [ -n "$7" ] ; then
                 OK_LABEL="$7"
              else
                 OK_LABEL="OK"
              fi
              #
              # Is there a label substitute for the "CANCEL" label?
              if [ -n "$8" ] ; then
                 CANCEL_LABEL="$8"
              else
                 CANCEL_LABEL="Cancel"
              fi
              #
              # Whiptail only has options --textbox or--msgbox (not --infobox in earlier versions).
              # f_msg_ui_str_box_size creates $ZNO which is the text string $4 but stripped of any Dialog "\Z" commands.
              whiptail --title "$3" --ok-button "$OK_LABEL" --msgbox "$ZNO" $Y $X
           ;;
      esac
      #
}  # End of function f_msg_ui_str_ok.
#
# +------------------------------+
# |   Function f_msg_ui_str_nok  |
# +------------------------------+
#
#     Rev: 2022-06-05
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "OK"  [OK] button at end of text.
#               "NOK" No [OK] button or "Press Enter key to continue"
#               at end of text but pause n seconds
#               to allow reader to read text by using sleep n command.
#               "NOK" DOES NOT WORK FOR WHIPTAIL. Earlier versions of Whiptail do not have an --infobox option to use for "NOK".
#          $3 - Title.
#          $4 - Text string or text file.
#          $5 - Box Height in characters.
#          $6 - Box Width  in characters.
#          $7 - Pause for $7 seconds to allow text to be read.
#          XSCREEN, YSCREEN.
#    Uses: None.
# Outputs: ERROR.
#
# Summary: Used by f_message. For Dialog or Whiptail UI only.
#          Display contents of a text string using a Dialog or Whiptail msgbox without an "OK" button.
#
# Dependencies: None.
#
f_msg_ui_str_nok () {
      #
      # $4 is a text string.
      # If $2 in "NOK" then use a Dialog infobox or Whiptail msgbox.
      #
      # Get the screen resolution or X-window size.
      # Get rows (height).
      YSCREEN=$(stty size | awk '{ print $1 }')
      # Get columns (width).
      XSCREEN=$(stty size | awk '{ print $2 }')
      #
      case $1 in
           dialog)
              # Dialog boxes "--msgbox" "--infobox" can use option --colors with "\Z" commands for font color bold/normal.
              # Dialog needs about 5 more lines for the header and [OK] button.
              let Y=$5+5
              # If number of lines exceeds screen/window height then set textbox height.
              if [ $Y -ge $YSCREEN ] ; then
                 Y=$YSCREEN
              fi
              #
              # Dialog needs about 10 more spaces for the right and left window frame.
              let X=$6+6
              # If line length exceeds screen/window width then set textbox width.
              if [ $X -ge $XSCREEN ] ; then
                 X=$XSCREEN
              fi
              #
              dialog --colors --no-ok --title "$3" --infobox "$4" $Y $X
              #
              # Is the pause for n seconds specified?
              if [ -z $7 ] ; then
                 # No, set a default n seconds to pause.
                 sleep 3
              else
                 # Yes, use n seconds to pause.
                 sleep "$7"
              fi
           ;;
           whiptail)
              # Whiptail only has options --textbox or--msgbox (not --infobox in earlier versions).
              # Whiptail does not have option "--colors" with "\Z" commands for font color bold/normal.
              #
              # Whiptail needs about 6 more lines for the header and [OK] button.
              let Y=$5+6
              # If number of lines exceeds screen/window height then set textbox height.
              if [ $Y -ge $YSCREEN ] ; then
                 Y=$YSCREEN
              fi
              #
              # Whiptail needs about 5 more spaces for the right and left window frame.
              let X=$6+5
              # If line length exceeds screen/window width then set textbox width.
              if [ $X -ge $XSCREEN ] ; then
                 X=$XSCREEN
              fi
              #
              # "NOK" DOES NOT WORK FOR WHIPTAIL. Earlier versions of Whiptail do not have an --infobox option to use for "NOK".
              # Whiptail only has options --textbox or--msgbox (not --infobox in earlier versions).
              # f_msg_ui_str_box_size creates $ZNO which is the text string $4 but stripped of any Dialog "\Z" commands.
              # Ideally we want to use whiptail --title "$3" --infobox "$ZNO" $Y $X
              whiptail --title "$3" --msgbox "$ZNO" $Y $X
           ;;
      esac
      #
}  # End of function f_msg_ui_str_nok.
#
# +------------------------------+
# |  Function f_msg_txt_str_ok   |
# +------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "OK"  [OK] button at end of text.
#               "NOK" No [OK] button or "Press Enter key to continue"
#               at end of text but pause n seconds
#               to allow reader to read text by using sleep n command.
#          $3 - Title.
#          $4 - Text string or text file.
#    Uses: None.
# Outputs: ERROR.
#
# Summary: Used by f_message. For Text UI only.
#          Display contents of a text string with "Press 'Enter' key to continue".
#
# Dependencies: f_press_enter_key_to_continue.
#
f_msg_txt_str_ok () {
      #
      # If $2 is "OK" then use f_press_enter_key_to_continue.
      #
      clear  # Blank the screen.
      #
      # Display title.
      echo
      echo -e $3
      echo
      echo
      # Display text string contents.
      echo -e $4
      echo
      f_press_enter_key_to_continue
      #
      clear  # Blank the screen.
      #
}  # End of function f_msg_txt_str_ok
#
# +------------------------------+
# |  Function f_msg_txt_str_nok  |
# +------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "OK"  [OK] button at end of text.
#               "NOK" No [OK] button or "Press Enter key to continue"
#               at end of text but pause n seconds
#               to allow reader to read text by using sleep n command.
#          $3 - Title.
#          $4 - Text string or text file.
#          $5 - Pause for $5 seconds to allow text to be read.
#    Uses: None.
# Outputs: ERROR.
#
# Summary: Used by f_message. For Text UI only.
#          Display contents of a text string with pause for $5 seconds.
#
# Dependencies: None.
#
f_msg_txt_str_nok () {
      #
      # If $2 is "NOK" then use "echo" followed by "sleep" commands
      # to give time to read it.
      #
      clear  # Blank the screen.
      #
      # Display title.
      echo
      echo -e "$3"
      echo
      echo
      # Display text string contents.
      echo -e "$4"
      echo
      echo
      #
      # Is the pause for n seconds specified?
      if [ -z $5 ] ; then
         # No, set a default n seconds to pause.
         sleep 3
      else
         # Yes, use n seconds to pause.
         sleep "$5"
      fi
      #
      clear  # Blank the screen.
      #
}  # End of function f_msg_txt_str_nok
#
# +------------------------------+
# |  Function f_msg_txt_file_ok  |
# +------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "OK"  [OK] button at end of text.
#               "NOK" No [OK] button or "Press Enter key to continue"
#               at end of text but pause n seconds
#               to allow reader to read text by using sleep n command.
#          $3 - Title.
#          $4 - Text string or text file.
#    Uses: None.
# Outputs: ERROR.
#
# Summary: Used by f_message. For Text UI only.
#          Display contents of a text file using command Less.
#
# Dependencies: less.
#
f_msg_txt_file_ok () {
      #
      # If $2 is "OK" then use command "less".
      #
      clear  # Blank the screen.
      #
      # Display text file contents.
      less -P '%P\% (Spacebar, PgUp/PgDn, Up/Dn arrows, press q to quit)' $4
      #
      clear  # Blank the screen.
      #
}  # End of function f_msg_txt_file_ok
#
# +------------------------------+
# |  Function f_msg_txt_file_nok |
# +------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - "OK"  [OK] button at end of text.
#               "NOK" No [OK] button or "Press Enter key to continue"
#               at end of text but pause n seconds
#               to allow reader to read text by using sleep n command.
#          $3 - Title.
#          $4 - Text string or text file.
#          $5 - Pause for $5 seconds to allow text to be read.
#    Uses: None.
# Outputs: ERROR.
#
# Summary: Used by f_message. For Text UI only.
#          Display contents of a text file with pause for $5 seconds.
#
# Dependencies: None.
#
f_msg_txt_file_nok () {
      #
      # If $2 is "NOK" then use "cat" and "sleep" commands to give time to read it.
      #
      clear  # Blank the screen.
      # Display title.
      echo
      echo $3
      echo
      echo
      # Display text file contents.
      cat $4
      #
      # Is the pause for n seconds specified?
      if [ -z $5 ] ; then
         # No, set a default n seconds to pause.
         sleep 3
      else
         # Yes, use n seconds to pause.
         sleep "$5"
      fi
      #
      #
      clear  # Blank the screen.
      #
}  # End of function f_msg_txt_file_nok
#
# +----------------------------------------+
# |        Function f_menu_arrays          |
# +----------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - file of menu choice strings.
#    Uses: ARRAY_NUM, ARRAY_NAME, ARRAY_VALUE, TEMP_FILE, XSTR.
# Outputs: MAX_CHOICE_LENGTH, MAX_SUMMARY_LENGTH, MAX_LINES, arrays CHOICE(n), SUMMARY(n), FUNC(n).
#
# Summary: Create an arrays CHOICE, SUMMARY, FUNC to store menu option information.
#
# Dependencies: None.
#
f_menu_arrays () {
      #
      # Create arrays CHOICE, SUMMARY, FUNC to store menu option information.
      #
      # Example:
      # Menu option name is "Directory Listing"
      # Shared directory to be mounted is "//hansolo/public/contacts"
      # Local PC mount-point is "/mnt/hansolo/contacts"
      #
      #     CHOICE[1]="Directory Listing"
      #     SUMMARY[1]="get a listing of files in a directory."
      #     FUNC[1]="f_dir_listing"     # Function to do command "ls -l".
      #
      unset CHOICE SUMMARY FUNC  # Delete arrays in memory.
      ARRAY_NUM=1
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
      #
      #                 Field-1 (null)  Field-2                      Field-3                     Field-4
      # Format of XSTR="<Delimiter> <Choice Title> <Delimiter> <Short Description> <Delimiter> <function>"
      #
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      #
      DELIM="#@@"
      while read XSTR
            do
               case $XSTR in
                    $DELIM*)
                       echo $XSTR >>$TEMP_FILE
                    ;;
               esac
            done < $1  # Read lines from file $1.
      #
      # Calculate number of lines or Menu Choices to find maximum menu lines
      # for Dialog or Whiptail.
      MAX_LINES=$(wc --lines <$TEMP_FILE)
      #
      MAX_CHOICE_LENGTH=0
      MAX_SUMMARY_LENGTH=0
      #
      while read XSTR
            do
               # Set array CHOICE[n] = <field-2> or "Choice Title" of XSTR.
               ARRAY_NAME="CHOICE"
               ARRAY_VALUE=$(echo $XSTR | awk -F "$DELIM" '{ if ( $3 ) { print $2 }}')
               ARRAY_VALUE=$(echo $ARRAY_VALUE | tr ' ' '_')
               eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
               #
               # Calculate length of next Menu Option Choice string.
               CHOICE_LENGTH=${#ARRAY_VALUE}
               # Save the value of the longest length of the Menu Option Choice.
               # This is for the text menu justification padding calculations.
               if [ $CHOICE_LENGTH -gt $MAX_CHOICE_LENGTH ] ; then
                  # Save new maximum string length.
                  MAX_CHOICE_LENGTH=$CHOICE_LENGTH
               fi
               #
               # Set array SUMMARY[n]=<field-3> or "Summary" of XSTR.
               ARRAY_NAME="SUMMARY"
               ARRAY_VALUE=$(echo $XSTR | awk -F "$DELIM" '{ if ( $3 ) { print $3 }}')
               ARRAY_VALUE=$(echo $ARRAY_VALUE | tr ' ' '_')
               eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
               #
               # Calculate length of next Menu Option Summary string.
               SUMMARY_LENGTH=${#ARRAY_VALUE}
               # Save the value of the longest length of the Menu Option Choice.
               # This is for the text menu justification padding calculations.
               if [ $SUMMARY_LENGTH -gt $MAX_SUMMARY_LENGTH ] ; then
                  # Save new maximum string length.
                  MAX_SUMMARY_LENGTH=$SUMMARY_LENGTH
               fi
               #
               # Set array $FUNC=<field-4> or "Function" of XSTR.
               ARRAY_NAME="FUNC"
               ARRAY_VALUE=$(echo $XSTR | awk -F "$DELIM" '{ if ( $3 ) { print $4 }}')
               ARRAY_VALUE=$(echo $ARRAY_VALUE | tr ' ' '_')
               eval $ARRAY_NAME[$ARRAY_NUM]=$ARRAY_VALUE
               #
               let ARRAY_NUM=$ARRAY_NUM+1
            done < $TEMP_FILE
      #
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      unset XSTR  # Throw out this variable.
      #
}  # End of f_menu_arrays.
#
# +----------------------------------------+
# |        Function f_update_menu_txt      |
# +----------------------------------------+
#
#     Rev: 2022-07-24
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - GENERATED_FILE.
#          $3 - Menu Title.
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#          $4 - MAX_CHOICE_LENGTH.
#          $5 - TEMP_FILE
#    Uses: X, Y, XNUM, YNUM, ARRAY_NAME, ARRAY_LEN, PAD, CHOICE.
# Outputs: None.
#
# Summary: Create a generated script file with executable script code to
#          display a Text UI Menu and case statement to take chosen action.
#
# Dependencies: None.
#
f_update_menu_txt () {
      #
      EXT=$(echo $2 | sed 's|\/|-|g')
      #
      echo "#!/bin/bash" >$2
      echo "#" >>$2
      # grep search THIS_FILE for Copyright line to include in generated file.
      # The option --text is needed because in some versions of grep, the
      # Copyright symbol character causes the script to be interpreted as a binary file.
      grep --max-count=1 --text Copyright $THIS_FILE >>$2
      echo "#" >>$2
      echo "# +----------------------------------------+" >>$2
      echo "# |        Default Variable Values         |" >>$2
      echo "# +----------------------------------------+" >>$2
      echo "#" >>$2
      echo "VERSION=\"$VERSION\"" >>$2
      echo "#" >>$2
      echo "#***********************************CAUTION***********************************" >>$2
      echo "# Any edits made to this code will be lost since this code is" >>$2
      echo "# automatically generated and updated by running the script," >>$2
      echo "# or library file which contains data for the menu." >>$2
      echo "#***********************************CAUTION***********************************" >>$2
      echo "#" >>$2
      echo "# *** Function f_menu_txt$EXT ***" >>$2
      echo "#" >>$2
      echo "#  Inputs: \$1 - \"text\", \"dialog\" or \"whiptail\" the command-line user-interface in use." >>$2
      echo "#    Uses: X, MENU_TITLE, ARRAY_NAME, ARRAY_LEN, CHOICE, SUMMARY, FUNC." >>$2
      echo "# Outputs: None." >>$2
      echo "#" >>$2
      echo "# Summary: Display a text menu which accepts alpha-numeric user-entered input." >>$2
      echo "#" >>$2
      echo "f_menu_txt$EXT () {" >>$2
      echo "      #" >>$2
      echo "      # Invoke the shared BASH Library." >>$2
      echo "      source $THIS_DIR/common_bash_function.lib" >>$2
      echo "      #" >>$2
      echo "      # Invoke script library." >>$2
      echo "      source $ARRAY_FILE" >>$2
      echo "      #" >>$2
      echo "      CHOICE=\"\"  # Initialize variable." >>$2
      echo "      until [ \"\$CHOICE\" = \"QUIT\" ]" >>$2
      echo "            do    # Start of menu until loop." >>$2
      echo "               clear  # Blank the screen." >>$2
      # Format string, substitute spaces for underscores.
      MENU_TITLE=$(echo $3 | tr '_' ' ') # Do not >>$2 this line.
      echo "               MENU_TITLE=\"$MENU_TITLE\"" >>$2
      echo "               echo \"               \$MENU_TITLE\"; echo" >>$2
      #
      # Get display screen or window size to get maximum width.
      # Get the screen resolution or X-window size.
      # Get rows (height).
      Y=$(stty size | awk '{ print $1 }')
      # Get columns (width).
      X=$(stty size | awk '{ print $2 }')
      #
      # Read both CHOICE and SUMMARY arrays and format strings to display
      # in a pretty formatted menu.
      ARRAY_NAME="CHOICE"
      ARRAY_LEN=$(eval "echo \$\{#$ARRAY_NAME[@]\}")
      ARRAY_LEN=$(eval echo $ARRAY_LEN)
      TEMP_FILE=$5
      #
      for (( XNUM=1; XNUM<=${ARRAY_LEN}; XNUM++ ));
          do
             ARRAY_NAME="CHOICE"
             CHOICE=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
             CHOICE=$(eval echo $CHOICE)
             CHOICE=$(echo $CHOICE | tr '_' ' ')
             # CHOICE_LC is a lower-case CHOICE string for the purpose of easier pattern matching in a case statement.
             CHOICE_LC=$(echo $CHOICE | tr \'[:upper:]\' \'[:lower:]\')
             #
             ARRAY_NAME="SUMMARY"
             SUMMARY=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
             SUMMARY=$(eval echo $SUMMARY)
             SUMMARY=$(echo $SUMMARY | tr '_' ' ')
             #
             ARRAY_NAME="FUNC"
             FUNC=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
             FUNC=$(eval echo $FUNC)
             # Allow for the passing of arguments when calling the function.
             # Change from FUNC="f_function^arg1^arg2" change to FUNC="f_function arg1 arg2".
             FUNC=$(echo $FUNC | tr '^' ' ')
             #
             let YNUM=$XNUM-1  # Start numbering choices from zero so zero selects CHOICE[1]
             #
             # Save the pattern matching for the case statement which is later inserted into the function, "f_menu_txt".
              echo "                    $YNUM | \"${CHOICE_LC:0:1}\" | \"${CHOICE_LC:0:2}\" | \"${CHOICE_LC:0:3}\" | \"${CHOICE_LC:0:4}\" | \"${CHOICE_LC:0:5}\" | \"${CHOICE_LC:0:6}\" | \"${CHOICE_LC:0:7}\" | \"${CHOICE_LC:0:8}\" | \"${CHOICE_LC:0:9}\" | \"${CHOICE_LC:0:10}\" | \"${CHOICE_LC:0:11}\" | \"${CHOICE_LC:0:12}\" | \"${CHOICE_LC:0:13}\" | \"${CHOICE_LC:0:14}\" | \"${CHOICE_LC:0:15}\") $FUNC  ;;" >>$TEMP_FILE
             #
             if [ -n "$CHOICE" ] ; then
                # Read next Menu Option Choice string and get its string length.
                CHOICE_LENGTH=${#CHOICE}
                if [ $CHOICE_LENGTH -lt $4 ] ; then
                   let PAD=$4-$CHOICE_LENGTH
                   until [ $PAD -eq 0 ]
                         do
                            # Pad spaces to right (left-justify CHOICE).
                            # CHOICE     - Summary description.
                            CHOICE=$CHOICE" "
                            #
                            # Pad spaces to left (right-justify CHOICE).
                            #     CHOICE - Summary description.
                            #CHOICE=" "$CHOICE
                            #
                            let PAD=$PAD-1
                         done
                fi
                # Truncate "CHOICE - Summary description"
                # if longer than maximum window or screen width.
                #
                # Example: "$YNUM $CHOICE - $SUMMARY"
                # CHOICE="0 Quit - Exit this menu." where array CHOICE[1]="Quit"
                CHOICE="$YNUM $CHOICE - $SUMMARY"
                CHOICE_LENGTH=${#CHOICE}
                # Is the length of string CHOICE plus SUMMARY > Maximum window width?
                if [ $CHOICE_LENGTH -gt $X ] ; then
                   # Yes, truncate SUMMARY length to fit maximum window or screen width.
                   let X=$X-3
                   CHOICE=${CHOICE:0:$X}"..."
                fi
                # No, leave length alone, just print to screen.
                echo "               echo \"$CHOICE\"" >>$2
             fi
          done
      echo "               echo" >>$2
      echo "               echo -n \" Enter 0-$YNUM or letters (0): \" ; read CHOICE" >>$2
      echo "               #CHOICE Convert to lower-case." >>$2
      echo "               CHOICE=\$(echo \$CHOICE | tr \'[:upper:]\' \'[:lower:]\')" >>$2
      echo "               #" >>$2
      echo "               case \$CHOICE in" >>$2
      echo "                    \"\") CHOICE=\"QUIT\" ;;  # Set default choice pattern match." >>$2
      # Case pattern matching statements are read from TEMP_FILE to be included here.
      cat $TEMP_FILE >>$2
      echo "               esac" >>$2
      echo "            done" >>$2
      echo "      #" >>$2
      echo "      clear  # Blank the screen." >>$2
      echo "      #" >>$2
      echo "      unset MENU_TITLE CHOICE  # Throw out this variable." >>$2
      echo "      #" >>$2
      echo "}  # End of function f_menu_txt$EXT." >>$2
      #
      # Remove $TEMP_FILE.
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      unset X Y XNUM YNUM MENU_TITLE ARRAY_NAME ARRAY_LEN CHOICE SUMMARY FUNC
      #
}  # End of function f_update_menu_txt.
#
# +----------------------------------------+
# |        Function f_update_menu_gui      |
# +----------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - GENERATED_FILE.
#          $3 - Menu Title.
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#          $4 - MAX_LENGTH
#          $5 - MAX_LINES
#          $6 - TEMP_FILE
#    Uses: GENERATED_FILE, ARRAY_NAME, ARRAY_LEN, XNUM.
# Outputs: None.
#
# Summary: Create a generated script file with executable script code to
#          display a Dialog/Whiptail UI Menu and case statement to take chosen action.
#
# Dependencies: None.
#
f_update_menu_gui () {
      #
      EXT=$(echo $2 | sed 's|\/|-|g')
      #
      echo "#!/bin/bash" >$2
      echo "#" >>$2
      # grep search THIS_FILE for Copyright line to include in generated file.
      # The option --text is needed because in some versions of grep, the
      # Copyright symbol character causes the script to be interpreted as a binary file.
      grep --max-count=1 --text Copyright $THIS_FILE >>$2
      echo "#" >>$2
      echo "# +----------------------------------------+" >>$2
      echo "# |        Default Variable Values         |" >>$2
      echo "# +----------------------------------------+" >>$2
      echo "#" >>$2
      echo "VERSION=\"$VERSION\"" >>$2
      echo "#" >>$2
      echo "#***********************************CAUTION***********************************" >>$2
      echo "# Any edits made to this code will be lost since this code is" >>$2
      echo "# automatically generated and updated by running the script," >>$2
      echo "# or library file which contains data for the menu." >>$2
      echo "#***********************************CAUTION***********************************" >>$2
      echo "#" >>$2
      echo "# *** Function f_menu_gui$EXT ***" >>$2
      echo "#" >>$2
      echo "#  Inputs: \$1 - \"text\", \"dialog\" or \"whiptail\" the command-line user-interface in use." >>$2
      echo "#    Uses: VERSION, THIS_FILE, CHOICE, SUMMARY, MENU_TITLE." >>$2
      echo "# Outputs: None." >>$2
      echo "#" >>$2
      echo "# Summary: Display a Whiptail/Dialog menu using the dialog/whiptail --menu option." >>$2
      echo "#" >>$2
      echo "f_menu_gui$EXT () {" >>$2
      echo "      #" >>$2
      echo "      # Invoke the shared BASH Library." >>$2
      echo "      source $THIS_DIR/common_bash_function.lib" >>$2
      echo "      #" >>$2
      echo "      # Invoke script library." >>$2
      echo "      source $ARRAY_FILE" >>$2
      echo "      #" >>$2
      echo "      # CHOICE=\"\"  # Initialize variable." >>$2
      #
      # Get the screen resolution or X-window size.
      # Get rows (height).
      Y=$(stty size | awk '{ print $1 }')
      # Get columns (width).
      X=$(stty size | awk '{ print $2 }')
      #
      echo "      until [ \"\$CHOICE\" = \"QUIT\" ]" >>$2
      echo "            do    # Start of Menu until loop." >>$2
      # Format string, substitute spaces for underscores.
                           MENU_TITLE=$(echo $3 | tr '_' ' ')
      echo "               MENU_TITLE=\"$MENU_TITLE\"" >>$2
      #
      # Pad menu contents width and height to include the menu frame.
      let XBOX=$4+9
      let YBOX=$5+9
      #
      # If screen or window width is greater than MAX_LENGTH_UI (number of characters).
      # Then shrink menu display to fit number of characters.
      if [ $XBOX -le $X ] ; then
         let X=$XBOX
      fi
      #
      # Pad vertical menu box display for a minimum display area.
      if [ $YBOX -le $Y ] ; then
         let Y=$YBOX
      fi
      #
      # Menu height - actual height of menu options.
      let Z=$5
      #
      case $1 in
           dialog)
              if [ $3 = "Main_Menu" ] ; then
                 echo "               CHOICE=\$(\$1 --no-cancel --clear --title \"\$MENU_TITLE\" --menu \"\n\nUse (up/down arrow keys) or (letters):\" $Y $X $Z \\" >>$2
              else
                 echo "               CHOICE=\$(\$1 --clear --title \"\$MENU_TITLE\" --menu \"\n\nUse (up/down arrow keys) or (letters):\" $Y $X $Z \\" >>$2
              fi
           ;;
           whiptail)
              if [ $3 = "Main_Menu" ] ; then
                 echo "               CHOICE=\$(\$1 --nocancel --clear --title \"\$MENU_TITLE\" --menu \"\n\nUse (up/down arrow keys) or (letters):\" $Y $X $Z \\" >>$2
              else
                 echo "               CHOICE=\$(\$1 --clear --title \"\$MENU_TITLE\" --menu \"\n\nUse (up/down arrow keys) or (letters):\" $Y $X $Z \\" >>$2
              fi
           ;;
      esac
      #
      #TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
      TEMP_FILE=$6
      ARRAY_NAME="CHOICE"
      ARRAY_LEN=$(eval "echo \$\{#$ARRAY_NAME[@]\}")
      ARRAY_LEN=$(eval echo $ARRAY_LEN)
            for (( XNUM=1; XNUM<=${ARRAY_LEN}; XNUM++ ));
                do
                   ARRAY_NAME="CHOICE"
                   CHOICE=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
                   CHOICE=$(eval echo $CHOICE)
                   CHOICE=$(echo $CHOICE | tr '_' ' ')
                   #
                   ARRAY_NAME="SUMMARY"
                   SUMMARY=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
                   SUMMARY=$(eval echo $SUMMARY)
                   SUMMARY=$(echo $SUMMARY | tr '_' ' ')
                   #
                   ARRAY_NAME="FUNC"
                   FUNC=$(eval "echo \$\{$ARRAY_NAME[$XNUM]\}")
                   FUNC=$(eval echo $FUNC)
                   # Allow for the passing of arguments when calling the function.
                   # Change from FUNC="f_function^arg1^arg2" change to FUNC="f_function arg1 arg2".
                   FUNC=$(echo $FUNC | tr '^' ' ')
                   #
                   if [ -n "$CHOICE" ] ; then
                      echo "                     \"$CHOICE\" \"$SUMMARY\" \\" >>$2
                      echo "                    \"$CHOICE\") $FUNC  ;;" >>$TEMP_FILE
                   fi
                done
      echo "               2>&1 >/dev/tty)" >>$2
      echo "               case \$CHOICE in" >>$2
      # Case pattern matching statements are read from TEMP_FILE to be included here.
      cat $TEMP_FILE >>$2
      echo "               esac" >>$2
      echo "            done" >>$2
      echo "       unset MENU_TITLE CHOICE  # Throw out this variable." >>$2
      echo "       #" >>$2
      echo "}  # End of function f_menu_gui$EXT." >>$2
      #
      # Remove $TEMP_FILE.
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      unset X Y XNUM ARRAY_NAME ARRAY_LEN CHOICE SUMMARY FUNC
      #
}  # End of function f_update_menu_gui.
#
# +-----------------------------------------+
# | Function f_menu_main_all_menus_TEMPLATE          |
# +-----------------------------------------+
#
#     Rev: 2024-01-19
#  Inputs: $1 - "text", "dialog" or "whiptail" the preferred user-interface.
#          $2 - MENU_TITLE Title of menu which must also match the header
#               and tail strings for the menu data in the ARRAY_SOURCE_FILE.
#              !!!Menu title MUST use underscores instead of spaces!!!
#          $3 - ARRAY_SOURCE_FILE is the file name where the menu data is stored.
#               This can be the run-time script or a separate *.lib library file.
#    Uses: ARRAY_SOURCE_FILE, ARRAY_TEMP_FILE, GENERATED_FILE, MENU_TITLE, TEMP_FILE.
# Outputs: None.
#
# Summary: Display any menu. Use this same function to display
#          both Main-Menu and any sub-menus. The Main Menu and all sub-menu data
#          are in a separte library file from the run-time script or program.
#          A single library file contains data for multiple menus (many menus/1 library file),
#          In this scheme, multiple menu data is in the library file,
#          which may also contain various functions in addition to the menu data.
#
#          Simply state the Path/Filename of the library file, ARRAY_SOURCE_FILE
#          which contains the menu data.
#
# Dependencies: f_menu_arrays, f_create_show_menu.
#
# PLEASE NOTE: RENAME THIS FUNCTION WITHOUT SUFFIX "_TEMPLATE" AND COPY
#              THIS FUNCTION INTO THE MAIN SCRIPT WHICH WILL CALL IT.
#
f_menu_main_all_menus_TEMPLATE () {
      #
      #
      #================================================================================
      # EDIT THE LINE BELOW TO DEFINE $ARRAY_SOURCE_FILE AS THE ACTUAL FILE NAME
      # WHERE THE MENU ITEM DATA IS LOCATED. THE LINES OF DATA ARE PREFIXED BY "#@@".
      #================================================================================
      #
      #
      # Note: Alternate menu data storage scheme.
      # For a separate library file for each menu data (1 menu/1 library file),
      # or for the run-time program to contain the Main Menu data (1 Main menu/run-time script),
      # then see f_menu_main_TEMPLATE in common_bash_function.lib
      #
      # Specify the library file name with menu item data.
      # ARRAY_SOURCE_FILE (Not a temporay file) includes menu items
      # from one or more menus (multiple menus/1 library file ARRAY_SOURCE_FILE).
      ARRAY_SOURCE_FILE=$3
      #
      #
      #================================================================================
      # EDIT THE LINE BELOW TO DEFINE MENU_TITLE AS THE ACTUAL TITLE OF THE MENU THAT
      # CONTAINS THE MENU ITEM DATA. THE LINES OF DATA ARE PREFIXED BY "#@@".
      #================================================================================
      #
      #
      # Note: ***If Menu title contains spaces,
      #       ***the size of the menu window will be too narrow.
      #
      # Menu title MUST use underscores instead of spaces.
      MENU_TITLE=$2
      #
      # Examples of valid $2 parameters:
      # MENU_TITLE="Main_Menu"
      # MENU_TITLE="Task_Menu"
      # MENU_TITLE="Utility_Menu"
      #
      # The MENU_TITLE must match the strings in the ARRAY_SOURCE_FILE.
      #
      #       The run-time script file, "ice_cream.sh" may also contain the data
      #       for both Main menu and sub-menus if it follows the same format below.
      #
      #       If you have a lot of menus, you may want to have all the menu data
      #       in a separate library file.
      #
      #       Example:
      #
      #       The file "all_ice_cream_menus.lib" contains the data for both
      #       Main menu: "Tasty Ice Cream Menu"
      #        Sub-menu: "Ice Cream Toppings Menu".
      #
      #  Each menu (Main Menu and sub-menus) must have Header and Tail strings.
      #  Main menu header/tail strings:
      #  Header string: "Start Listing Tasty Ice Cream Menu" (with spaces " ")
      #    Tail string: "End Listing Tasty Ice Cream Menu"
      #
      #  Sub-menu header/tail strings:
      #  Header string: "Start Listing Ice Cream Toppings Menu"
      #    Tail string: "End Listing Ice Cream Toppings Menu"
      #
      #
      #  Example:
      #
      #  ARRAY_SOURCE_FILE="All_Ice_Cream_Menus.lib"
      #
      #  Listing of $ARRAY_SOURCE_FILE (All_Ice_Cream_Menus.lib)
      #          which includes menu item data:
      #
      #  Start Listing Tasty Ice Cream Menu (Required header, do not delete).
      #      Data for Menu item 1
      #      Data for Menu item 2
      #      Data for Menu item 3
      #  End  Listing Tasty Ice Cream Menu (Required line, do not delete).
      #
      #  Start Listing Ice Cream Toppings Menu (Required header, do not delete).
      #      Data for Menu item 1
      #      Data for Menu item 2
      #      Data for Menu item 3
      #  End Listing Ice Cream Toppings Menu (Required line, do not delete).
      #
      #
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_menu_temp.txt"
      #
      # GENERATED_FILE (The name of a temporary library file which contains the code to display the sub-menu).
      GENERATED_FILE=$THIS_DIR/$THIS_FILE"_menu_generated.lib"
      #
      # ARRAY_TEMP_FILE (Temporary file) includes menu items imported from $ARRAY_SOURCE_FILE of a single menu.
      ARRAY_TEMP_FILE=$THIS_DIR/$THIS_FILE"_menu_array_generated.lib"
      #
      # ARRAY_FILE is used by f_update_menu_gui and f_update_menu_txt.
      # It is not included in formal passed parameters but is used anyways
      # in the $GENERATED_FILE as a line: "source $ARRAY_FILE".
      # I wanted to retire this variable name, but it has existed in the
      # common_bash_function.lib library for quite a while.
      ARRAY_FILE=$GENERATED_FILE
      #
      # When using f_create_a_menu, all subsequent sub-menus do not need a separate
      # hard-coded function, since f_create_a_menu will generate sub-menu functions as needed.
      #
      # List of inputs for f_create_a_menu.
      #
      #  Inputs: $1 - "text", "dialog" or "whiptail" The command-line user-interface application in use.
      #          $2 - GENERATED_FILE (The name of a temporary library file containing the suggested phrase "generated.lib" which contains the code to display the sub-menu).
      #          $3 - MENU_TITLE (Title of the sub-menu)
      #          $4 - TEMP_FILE (Temporary file).
      #          $5 - ARRAY_TEMP_FILE (Temporary file) includes menu items imported from $ARRAY_SOURCE_FILE of a single menu.
      #          $6 - ARRAY_SOURCE_FILE (Not a temporary file) includes menu items from multiple menus.
      #
      f_create_a_menu $1 $GENERATED_FILE $MENU_TITLE $TEMP_FILE $ARRAY_TEMP_FILE $ARRAY_SOURCE_FILE
      #
      if [ -e $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      #
      if [ -e  $GENERATED_FILE ] ; then
         rm  $GENERATED_FILE
      fi
      #
} # End of function f_menu_main_all_menus_TEMPLATE
#
# +----------------------------------------+
# |          Function f_menu_main_TEMPLATE          |
# +----------------------------------------+
#
#     Rev: 2024-01-13
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#    Uses: ARRAY_SOURCE_FILE, GENERATED_FILE, MENU_TITLE, TEMP_FILE,
#          MAX_LENGTH, MAX_CHOICE_LENGTH, MAX_SUMMARY_LENGTH.
# Outputs: None.
#
# Summary: Template for Main-Menu where the ARRAY_SOURCE_FILE can contain data for only 1 menu.
#          For sub-menus, this template and the sub-menu data must both be in a separate ARRAY_SOURCE_FILE.
#
#          Please see f_menu_main_all_menus_TEMPLATE for a much more flexible menu template
#          for both Main Menus and sub-menus.
#
#          This Main Menu function checks the run-time script for the Main Menu
#          options delimited by "#@@" and if it does not find any, then
#          it it defaults to the specified library script.
#
#          Either the run-time file or library file can contain menu item data for a SINGLE menu only.
#          With this scheme, a separate library file is needed for each menu (1 menu/1 library file).
#          So the Main menu data may be either in the run-time script or in a separate library file.
#
#          Note: Alternate menu data storage scheme.
#          For a single library file containg data for multiple menus (many menus/1 library file),
#          then see f_menu_multiple_TEMPLATE in common_bash_function.lib.
#
# Dependencies: f_menu_arrays, f_create_show_menu.
#
# PLEASE NOTE: RENAME THIS FUNCTION WITHOUT SUFFIX "_TEMPLATE" AND COPY
#              THIS FUNCTION INTO THE MAIN SCRIPT WHICH WILL CALL IT.
#
f_menu_main_TEMPLATE () {
      #
      # Note: ***If Menu title contains spaces,
      #       ***the size of the menu window will be too narrow.
      #
      # Menu title MUST use underscores instead of spaces.
      MENU_TITLE="Main_Menu"
      #
      # Create and display the Main Menu.
      GENERATED_FILE=$THIS_DIR/$THIS_FILE"_menu_main_generated.lib"
      #
      # Does this file have menu items in the comment lines starting with "#@@"?
      grep --silent ^\#@@ $THIS_DIR/$THIS_FILE
      ERROR=$?
      # exit code 0 - menu items in this file.
      #           1 - no menu items in this file.
      #               file name of file containing menu items must be specified.
      #
      if [ $ERROR -eq 0 ] ; then
         # Extract menu items from this file and insert them into the Generated file.
         # This is required because f_menu_arrays cannot read this file directly without
         # going into an infinite loop.
         grep ^\#@@ $THIS_DIR/$THIS_FILE >$GENERATED_FILE
         #
         # Specify file name with menu item data.
         ARRAY_SOURCE_FILE="$GENERATED_FILE"
      else
         #
         #
         #==================================================================
         # EDIT THE LINE BELOW TO DEFINE $ARRAY_FILE AS THE ACTUAL FILE NAME
         # (LIBRARY) WHERE THE MENU ITEM DATA IS LOCATED. THE LINES OF DATA
         # ARE PREFIXED BY "#@@".
         #==================================================================
         #
         #
         # Note: Alternate menu data storage scheme.
         # For a single library file containg data for multiple menus (many menus/1 library file),
         # then see f_menu_multiple_TEMPLATE in common_bash_function.lib.
         #
         # Specify library file name with menu item data.
         # Library file contains menu item data for a SINGLE menu only.
         # With this scheme, a separate library file is needed for each menu (1 menu/1 library file).
         # So the Main menu data may be either in the run-time script or in a separate library file.
         #
         # ARRAY_FILE="[FILENAME_GOES_HERE]"
           ARRAY_SOURCE_FILE="$THIS_DIR/[FILENAME_GOES_HERE]"
      fi
      #
      # Create arrays from data.
      f_menu_arrays $ARRAY_SOURCE_FILE
      #
      # Calculate longest line length to find maximum menu width
      # for Dialog or Whiptail using lengths calculated by f_menu_arrays.
      let MAX_LENGTH=$MAX_CHOICE_LENGTH+$MAX_SUMMARY_LENGTH
      #
      # Create generated menu script from array data.
      #
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_menu_main_temp.txt"
      #
      # ARRAY_FILE is used by f_update_menu_gui and f_update_menu_txt.
      # It is not included in formal passed parameters but is used anyways
      # in the $GENERATED_FILE as a line: "source $ARRAY_FILE".
      # I wanted to retire this variable name, but it has existed in the
      # common_bash_function.lib library for quite a while.
      ARRAY_FILE=$GENERATED_FILE
      #
      f_create_show_menu $1 $GENERATED_FILE $MENU_TITLE $MAX_LENGTH $MAX_LINES $MAX_CHOICE_LENGTH $TEMP_FILE
      #
      if [ -r $GENERATED_FILE ] ; then
         rm $GENERATED_FILE
      fi
      #
      if [ -r $TEMP_FILE ] ; then
         rm $TEMP_FILE
      fi
      #
}  # End of function f_menu_main_TEMPLATE.
#
# +----------------------------------------+
# |         Function f_create_a_menu       |
# +----------------------------------------+
#
#     Rev: 2022-05-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - GENERATED_FILE (The name of a temporary library file containing the suggested phrase "generated.lib" which contains the code to display the sub-menu).
#          $3 - MENU_TITLE (Title of the sub-menu)
#          $4 - TEMP_FILE (Temporary file).
#          $5 - ARRAY_TEMP_FILE (Temporary file) includes menu items imported from $ARRAY_SOURCE_FILE of a single menu.
#          $6 - ARRAY_SOURCE_FILE (Not a temporay file) includes menu items from multiple menus.
#    Uses: None.
# Outputs: None.
#
# Summary: Display Main Menu and/or Sub-menus using menu data from a single file which includes all the menu items for multiple menus.
#          So rather than having a separate file for the data of each menu, this allows you to have data for multiple menus in a single file.
#          This may replace f_menu_sub_TEMPLATE.
#
#       The run-time script file, "ice_cream.sh" may also contain the data
#       for both Main menu and sub-menus if it follows the same format below.
#
#       If you have a lot of menus, you may want to have all the menu data
#       in a separate library file.
#
#       Example:
#       The file "All_Ice_Cream_Menus.lib" contains the data for both
#       Main menu: "Tasty Ice Cream Menu"
#        Sub-menu: "Ice Cream Toppings Menu".
#
#       Each menu (Main Menu and sub-menus) must have Header and Tail strings.
#       Main menu header/tail strings:
#       Header string: "Start Listing Tasty Ice Cream Menu" (with spaces " ")
#         Tail string: "End Listing Tasty Ice Cream Menu"
#       must be used in the header/tail string sentences of the menu item data.
#
#       Sub-menu header/tail strings:
#       Header string: "Start Listing Ice Cream Toppings Menu"
#         Tail string: "End Listing Ice Cream Toppings Menu"
#
#       ARRAY_SOURCE_FILE="All_Ice_Cream_Menus.lib"
#
#       Listing of $ARRAY_SOURCE_FILE (All_Ice_Cream_Menus.lib)
#               which includes menu item data:
#
#       Start Listing Tasty Ice Cream Menu (Required header, do not delete).
#           Data for Menu item 1
#           Data for Menu item 2
#           Data for Menu item 3
#       End  Listing Tasty Ice Cream Menu (Required line, do not delete).
#
#       Start Listing Ice Cream Toppings Menu (Required header, do not delete).
#           Data for Menu item 1
#           Data for Menu item 2
#           Data for Menu item 3
#       End Listing Ice Cream Toppings Menu (Required line, do not delete).
#
# Dependencies: f_menu_make, f_menu_arrays, f_create_show_menu.
#
f_create_a_menu () {
      #
      # Create $ARRAY_FILE from Array Source File.
      f_menu_make $1 $3 $5 $6
      #
      # Create arrays from data.
      f_menu_arrays $5
      #
      # Calculate longest line length to find maximum menu width
      # for Dialog or Whiptail using lengths calculated by f_menu_arrays.
      # f_menu_arrays sets MAX_CHOICE_LENGTH and MAX_SUMMARY_LENGTH.
      # So this calculation must come after call to f_menu_arrays.
      let MAX_LENGTH=$MAX_CHOICE_LENGTH+$MAX_SUMMARY_LENGTH
      #
      # Create generated menu script from array data.
      #  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
      #          $2 - GENERATED_FILE.
      #          $3 - Menu Title.
      #                  (String must either begin and end with double-quotes
      #                  or must have underscores substituting for spaces).
      #          $4 - MAX_LENGTH.
      #          $5 - MAX_LINES.
      #          $6 - MAX_CHOICE_LENGTH
      #          $7 - TEMP_FILE
      f_create_show_menu $1 $2 $3 $MAX_LENGTH $MAX_LINES $MAX_CHOICE_LENGTH $4
      #
      if [ -r $2 ] ; then
         rm $2
      fi
      #
      if [ -r $4 ] ; then
         rm $4
      fi
      #
      if [ -e $5 ] ; then
         rm $5
      fi
      #
      #
}  # End of function f_create_a_menu.
#
# +----------------------------------------+
# |          Function f_create_menu        |
# +----------------------------------------+
#
#     Rev: 2022-05-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - GENERATED_FILE (The name of a temporary library file containing the suggested phrase "generated.lib" which contains the code to display the sub-menu).
#          $3 - MENU_TITLE (Title of the sub-menu)
#          $4 - TEMP_FILE (Temporary file).
#          $5 - ARRAY_TEMP_FILE (Temporary file) includes menu items imported from $ARRAY_SOURCE_FILE of a single menu.
#    Uses: None.
# Outputs: None.
#
# Summary: Display sub-menu. This may replace f_menu_sub_TEMPLATE.
#
# Dependencies: f_menu_make, f_menu_arrays, f_create_show_menu.
#
f_create_menu () {
      #
      # Create arrays from data.
      f_menu_arrays $5
      #
      # Calculate longest line length to find maximum menu width
      # for Dialog or Whiptail using lengths calculated by f_menu_arrays.
      # f_menu_arrays sets MAX_CHOICE_LENGTH and MAX_SUMMARY_LENGTH.
      # So this calculation must come after call to f_menu_arrays.
      let MAX_LENGTH=$MAX_CHOICE_LENGTH+$MAX_SUMMARY_LENGTH
      #
      # Create generated menu script from array data.
      #  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
      #          $2 - GENERATED_FILE.
      #          $3 - Menu Title.
      #                  (String must either begin and end with double-quotes
      #                  or must have underscores substituting for spaces).
      #          $4 - MAX_LENGTH.
      #          $5 - MAX_LINES.
      #          $6 - MAX_CHOICE_LENGTH
      #          $7 - TEMP_FILE
      f_create_show_menu $1 $2 $3 $MAX_LENGTH $MAX_LINES $MAX_CHOICE_LENGTH $4
      #
      if [ -r $2 ] ; then
         rm $2
      fi
      #
      if [ -r $4 ] ; then
         rm $4
      fi
      #
      if [ -e $5 ] ; then
         rm $5
      fi
      #
      #
}  # End of function f_create_menu.
#
# +----------------------------------------+
# |          Function f_menu_make          |
# +----------------------------------------+
#
#  Inputs: $1 - GUI - "dialog" or "whiptail" The CLI GUI application in use.
#          $2 - Menu title string to use with grep to find correct menu items.
#          $3 - ARRAY_FILE name (Temporary file) includes menu items imported from $ARRAY_SOURCE_FILE of a single menu.
#          $4 - ARRAY_SOURCE_FILE name (Not a temporay file) includes menu items from multiple menus.
#          THIS_DIR, THIS_FILE.
#    Uses: MENU_TITLE SEDSTR STARTING_LINE ENDING_LINE.
# Outputs: $3 - ARRAY_FILE (Temporary file) includes menu items imported from $ARRAY_SOURCE_FILE of a single menu.
#
# Summary: Create a temporary file of menu items for a single menu from the
#          $ARRAY_SOURCE_FILE which contains menu items for multiple menus.
#
# Dependencies: None.
#
f_menu_make () {
      #
      # Format string, substitute spaces for underscores.
      MENU_TITLE=$(echo $2 | tr "_" " ")
      #
      STARTING_LINE=$(grep -n "Start Listing $MENU_TITLE" $4 | awk -F ":" '{print $1 }')
      ENDING_LINE=$(grep -n "End Listing $MENU_TITLE"     $4 | awk -F ":" '{print $1 }')
      #
      # Copy text between $STARTING_LINE and $ENDING_LINE into a text file.
      # Create sed command "$STARTING_LINE,$ENDING_LINEp" i.e. "31,51p" for STARTING_LINE=31, ENDING_LINE=51.
      SEDSTR="$STARTING_LINE,$ENDING_LINE"
      SEDSTR=$SEDSTR"p"
      #
      # Use eval command because of substitution of variable $SEDSTR for the actual sed command.
      eval sed -n '$SEDSTR' $4 > $3
      #
      unset MENU_TITLE SEDSTR STARTING_LINE ENDING_LINE
      #
}  # End of function f_menu_make.
#
# +----------------------------------------+
# |       Function f_create_show_menu      |
# +----------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - GENERATED_FILE.
#          $3 - Menu Title.
#                  (String must either begin and end with double-quotes
#                  or must have underscores substituting for spaces).
#          $4 - MAX_LENGTH.
#          $5 - MAX_LINES.
#          $6 - MAX_CHOICE_LENGTH
#          $7 - TEMP_FILE
#    Uses: GENERATED_FILE, ARRAY_NAME, ARRAY_LEN, XNUM.
# Outputs: None.
#
# Summary: Call functions to create menu and then source the generated file
#          and display the menu.
#
# Dependencies: f_update_menu_gui, f_update_menu_txt, f_menu_gui$EXT, f_menu_txt$EXT.
#
f_create_show_menu () {
      #
      case $1 in
           "dialog" | "whiptail")
              f_update_menu_gui $1 $2 "$3" $4 $5 $7
           ;;
           "text")
              f_update_menu_txt $1 $2 "$3" $6 $7
           ;;
      esac
      #
      source $2 $1  # Invoke Generated File.
      #
      # Use generated menu script to display menu.
      # Create a unique function name extension used in the Generated File.
      EXT=$(echo $2 | sed 's|\/|-|g')
      #
      case $1 in
           "dialog" | "whiptail")
              f_menu_gui$EXT $1 "$3"
           ;;
           "text")
              f_menu_txt$EXT
           ;;
       esac
      #
      if [ -r $2 ] ; then
         rm $2
      fi
      #
      clear  # Blank the screen.
      #
}  # End of function f_create_show_menu.
#
# +----------------------------------------+
# |             Function f_mount           |
# +----------------------------------------+
#
#     Rev: 2022-01-21
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - File server Directory
#          $3 - Mount Point (Directory)
#          $4 - Default User Name (OPTIONAL)
#    Uses: USERNAME_DEFAULT
# Outputs: ERROR, TEMP_FILE.
#
# Summary: Mount directory using Samba and CIFS.
#
# Dependencies: f_username, f_password.
#               Software package "cifs-utils" in the Distro's Repository.
#
f_mount () {
      #
      mountpoint $3 >/dev/null 2>$TEMP_FILE
      # Write any error messages to file $TEMP_FILE. Get status of mountpoint, mounted?.
      ERROR=$?
      #
      # Is the directory mounted?
      if [ $ERROR -ne 0 ] ; then
         # No, mount the directory.
         #
         # Set default user name.
         USERNAME_DEFAULT=$4
         # Is the default user name a passed parameter?
         if [ -z $4 ] ; then
            # No, set user name to $USER.
            USERNAME_DEFAULT=$USER
         fi
         #
         f_username $1 "$USERNAME_DEFAULT" $3
         if [ $ERROR -eq 0 ] ; then
            f_password $1 $3
            if [ $ERROR -eq 0 ] ; then
               sudo mount -t cifs -o username="$SMBUSER" -o password="$PASSWORD" $2 $3
               mountpoint $3 >/dev/null 2>$TEMP_FILE # Write any error messages to file $TEMP_FILE. Get status of mountpoint, mounted?.
               ERROR=$?
            fi
         fi
      fi
      #
      unset USERNAME_DEFAULT
      #
}  # End of function f_mount.
#
# +----------------------------------------+
# |              f_download_file           |
# +----------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - DL_SOURCE ("Local" or "Web")
#          $3 - SERVER_DIR File server directory.
#          $4 - MP_DIR Mount-point directory.
#          $5 - DL_REPOSITORY Download Repository on the web.
#          $6 - DL_FILE File to download.
#    Uses: None.
# Outputs: ERROR.
#
# Summary: If a library file is missing, download it from a repository.
#
# Dependencies: f_download_from_web_site, f_download_from_local_repository.
#
f_download_file () { # Create and display the Main Menu.
      #
      #
      #===================================================================
      # EDIT THE LINE BELOW WITH THE LOCAL REPOSITORY DIRECTORY ON THE PC.
      #===================================================================
      #
      #
      LOCAL_REPO_DIR="$4/scripts/BASH/Repository"
      #
      case $2 in
           Local)
              # Download from Local Repository on LAN File Server.
              # Are LAN File Server directories available on Local Mount-point?
              f_mount $1 $3 $4
              #
              if [ $ERROR -ne 0 ] ; then
                 # Failed to mount LAN File Server directory on Local Mount-point.
                 # So download from Web Repository.
                 f_download_from_web_site $1 $5 $6
              else
                 # Sucessful mount of LAN File Server directory.
                 # Continue with download from Local Repository on LAN File Server.
                 f_download_from_local_repository $LOCAL_REPO_DIR $6
                 #
                 if [ $ERROR -ne 0 ] ; then
                    # Failed to download from Local Repository on LAN File Server.
                    # So download from Web Repository.
                    f_download_from_web_site $5 $6
                 fi
              fi
              ;;
           Web)
              # Download from Web Repository.
              f_download_from_web_site $5 $6
              if [ $ERROR -ne 0 ] ; then
                 # Failed so mount LAN File Server directory on Local Mount-point.
                 f_mount $1 $3 $4
                 #
                 if [ $ERROR -eq 0 ] ; then
                    # Successful mount of LAN File Server directory.
                    # Continue with download from Local Repository on LAN File Server.
                    f_download_from_local_repository $LOCAL_REPO_DIR $6
                 fi
              fi
              ;;
      esac
      #
}  # End of function f_download_file.
#
# +----------------------------------------+
# |          f_download_from_web_site      |
# +----------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - DL_REPOSITORY Download Repository URL on the web.
#          $3 - DL_FILE File to download.
#    Uses: LINE.
# Outputs: ERROR.
#
# Summary: Download a list of file names from a web site.
#
# Dependencies: wget, f_message.
#
f_download_from_web_site () {
      #
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
      #
      echo >$TEMP_FILE
      echo ">>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<" >>$TEMP_FILE
      echo ">>> Download file from Web Repository <<<" >>$TEMP_FILE
      echo ">>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<" >>$TEMP_FILE
      echo >>$TEMP_FILE
      f_message $1 "NOK" "Download" $TEMP_FILE
      #
      # $2 ends with a slash "/" so can append $3 immediately after $2.
      wget --show-progress $2$3
      ERROR=$?
      if [ $ERROR -ne 0 ] ; then
            echo >$TEMP_FILE
            echo ">>>>>>>>>>>>>><<<<<<<<<<<<<<" >>$TEMP_FILE
            echo ">>> wget download failed <<<" >>$TEMP_FILE
            echo ">>>>>>>>>>>>>><<<<<<<<<<<<<<" >>$TEMP_FILE
            echo >>$TEMP_FILE
            echo "Error copying from Web Repository file: \"$3.\"" >>$TEMP_FILE
            echo >>$TEMP_FILE
            f_message $1 "NOK" "Download Error" $TEMP_FILE
      else
         # Make file executable (useable).
         chmod +x $3
         #
         if [ -x $3 ] ; then
            # File is good.
            ERROR=0
         else
            echo >$TEMP_FILE
            echo ">>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<" >>$TEMP_FILE
            echo ">>> File Error after download from Web Repository <<<" >>$TEMP_FILE
            echo ">>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<" >>$TEMP_FILE
            echo >>$TEMP_FILE
            echo "$3 is missing or file is not executable." >>$TEMP_FILE
            echo >>$TEMP_FILE
            f_message $1 "NOK" "Download Error" $TEMP_FILE

         fi
      fi
      #
      # Make downloaded file executable.
      chmod 755 $3
      #
}  # End of function f_download_from_web_site.
#
# +-----------------------------------------------+
# |   Function f_download_from_local_repository   |
# +-----------------------------------------------+
#
#     Rev: 2021-03-07
#  Inputs: $1 - "text", "dialog" or "whiptail" the command-line user-interface in use.
#          $2 - Local Repository Directory.
#          $3 - File to download.
#    Uses: TEMP_FILE.
# Outputs: ERROR.
#
# Summary: Copy a file from the local repository on the LAN file server.
#
# Dependencies: f_message.
#
f_download_from_local_repository () {
      #
      TEMP_FILE=$THIS_DIR/$THIS_FILE"_temp.txt"
      #
      echo >$TEMP_FILE
      echo ">>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<" >>$TEMP_FILE
      echo ">>> File Copy from Local Repository <<<" >>$TEMP_FILE
      echo ">>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<" >>$TEMP_FILE
      echo >>$TEMP_FILE
      f_message $1 "NOK" "File Copy" $TEMP_FILE
      #
      # $2 ends with a slash "/" so can append $3 immediately after $2.
      eval cp -p $2/$3 .
      ERROR=$?
      #
      if [ $ERROR -ne 0 ] ; then
         echo >$TEMP_FILE
         echo ">>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<" >>$TEMP_FILE
         echo ">>> File Copy Error from Local Repository <<<" >>$TEMP_FILE
         echo ">>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<" >>$TEMP_FILE
         echo >>$TEMP_FILE
         echo -e "Error copying from Local Repository file: \"$3.\"" >>$TEMP_FILE
         echo >>$TEMP_FILE
         f_message $1 "NOK" "Copy Error" $TEMP_FILE
         ERROR=1
      else
         # Make file executable (useable).
         chmod +x $3
         #
         if [ -x $3 ] ; then
            # File is good.
            ERROR=0
         else
            echo >$TEMP_FILE
            echo ">>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<" >>$TEMP_FILE
            echo ">>> File Error after copy from Local Repository <<<" >>$TEMP_FILE
            echo ">>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<" >>$TEMP_FILE
            echo >>$TEMP_FILE
            echo -e "File \"$3\" is missing or file is not executable." >>$TEMP_FILE
            echo >>$TEMP_FILE
            f_message $1 "NOK" "File not executable" $TEMP_FILE
          ERROR=1
         fi
      fi
      #
      if [ $ERROR -eq 0 ] ; then
         echo >$TEMP_FILE
         echo "Successful Update of file \"$3\" to latest version." >>$TEMP_FILE
         echo >>$TEMP_FILE
         echo "Script must be re-started to use the latest version." >>$TEMP_FILE
         echo "____________________________________________________" >>$TEMP_FILE
         f_message $1 "NOK" "Successful Update" $TEMP_FILE
      fi
      #
}  # End of function f_download_from_local_repository.
#
# +----------------------------------------+
# |             Function f_source          |
# +----------------------------------------+
#
#     Rev: 2021-03-08
#  Inputs: $1 - File name to source.
# Outputs: ERROR.
#
# Summary: Source the provided library file.
#
# Dependencies: None.
#
f_source () {
      #
      # Initialize ERROR.
      ERROR=0
      #
      if [ -x "$1" ] ; then
         # If $1 is a library, then source it.
         case $1 in
              *.lib)
                 source $1
                 ERROR=$?
              ;;
         esac
      fi
      #
}  # End of function f_source.
#
